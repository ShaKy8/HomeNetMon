window.NetworkTopology = {svg: null, simulation: null, nodes: [], links: [], width: 800, height: 600, initialized: false };function initializeNetworkTopology() {const container = document.getElementById('network-topology');if (!container || NetworkTopology.initialized) return;console.log('Initializing network topology...');if (typeof d3 === 'undefined') {console.warn('D3.js not available, topology visualization disabled');container.innerHTML = '<div class="alert alert-warning">Network topology visualization requires D3.js</div>';return}setupTopologyContainer(container);loadNetworkData();NetworkTopology.initialized = true;console.log('Network topology initialized')}function setupTopologyContainer(container) {const rect = container.getBoundingClientRect();NetworkTopology.width = rect.width || 800;NetworkTopology.height = rect.height || 600;NetworkTopology.svg = d3.select(container) .append('svg') .attr('width', NetworkTopology.width) .attr('height', NetworkTopology.height) .attr('viewBox', [0, 0, NetworkTopology.width, NetworkTopology.height]);const zoom = d3.zoom() .scaleExtent([0.1, 4]) .on('zoom', function(event) {NetworkTopology.svg.select('g').attr('transform', event.transform)});NetworkTopology.svg.call(zoom);const g = NetworkTopology.svg.append('g');NetworkTopology.svg.append('defs') .selectAll('marker') .data(['end']) .enter() .append('marker') .attr('id', 'arrow') .attr('viewBox', '0 -5 10 10') .attr('refX', 20) .attr('refY', 0) .attr('markerWidth', 6) .attr('markerHeight', 6) .attr('orient', 'auto') .append('path') .attr('d', 'M0,-5L10,0L0,5') .attr('class', 'arrow-marker')}function loadNetworkData() {if (!window.HomeNetMon || !window.HomeNetMon.apiCall) {console.error('HomeNetMon API not available');return}window.HomeNetMon.apiCall('/devices') .then(response => {if (response.success) {createTopologyFromDevices(response.devices)}}) .catch(error => {console.error('Failed to load network data:', error);showTopologyError('Failed to load network data')})}function createTopologyFromDevices(devices) {if (!devices || devices.length === 0) {showTopologyError('No devices found');return}const nodes = prepareNodes(devices);const links = prepareLinks(devices);createForceSimulation(nodes, links);NetworkTopology.nodes = nodes;NetworkTopology.links = links}function prepareNodes(devices) {return devices.map(device => ({id: device.id, name: device.display_name || device.hostname || device.ip_address, ip: device.ip_address, status: device.status, device_type: device.device_type, response_time: device.latest_response_time, isGateway: device.ip_address.endsWith('.1'), isServer: device.device_type === 'server' || device.ip_address.endsWith('.100'), x: Math.random() * NetworkTopology.width, y: Math.random() * NetworkTopology.height }))}function prepareLinks(devices) {const links = [];const gateway = devices.find(d => d.ip_address.endsWith('.1'));if (gateway) {devices.forEach(device => {if (device.id !== gateway.id) {links.push({source: gateway.id, target: device.id, type: 'network' })}})}const servers = devices.filter(d => d.device_type === 'server' || d.ip_address.endsWith('.100'));const clients = devices.filter(d => !d.ip_address.endsWith('.1') && d.device_type !== 'server');servers.forEach(server => {const connectedClients = clients.slice(0, Math.min(5, clients.length));connectedClients.forEach(client => {if (!links.some(l => (l.source === server.id && l.target === client.id) || (l.source === client.id && l.target === server.id))) {links.push({source: server.id, target: client.id, type: 'service' })}})});return links}function createForceSimulation(nodes, links) {NetworkTopology.svg.select('g').selectAll('*').remove();const g = NetworkTopology.svg.select('g');NetworkTopology.simulation = d3.forceSimulation(nodes) .force('link', d3.forceLink(links).id(d => d.id).distance(100)) .force('charge', d3.forceManyBody().strength(-300)) .force('center', d3.forceCenter(NetworkTopology.width / 2, NetworkTopology.height / 2)) .force('collision', d3.forceCollide().radius(30));const link = g.append('g') .attr('class', 'links') .selectAll('line') .data(links) .enter() .append('line') .attr('class', d => `link link-${d.type}`) .attr('marker-end', 'url(#arrow)');const node = g.append('g') .attr('class', 'nodes') .selectAll('g') .data(nodes) .enter() .append('g') .attr('class', 'node') .call(d3.drag() .on('start', dragStarted) .on('drag', dragged) .on('end', dragEnded));node.append('circle') .attr('r', d => getNodeRadius(d)) .attr('class', d => `node-circle status-${d.status}`) .attr('fill', d => getNodeColor(d));node.append('text') .attr('dx', 12) .attr('dy', '.35em') .attr('class', 'node-label') .text(d => d.name);node.append('title') .text(d => `${d.name}\n${d.ip}\nStatus: ${d.status}\nResponse: ${d.response_time || 'N/A'}ms`);NetworkTopology.simulation.on('tick', () => {link .attr('x1', d => d.source.x) .attr('y1', d => d.source.y) .attr('x2', d => d.target.x) .attr('y2', d => d.target.y);node .attr('transform', d => `translate(${d.x},${d.y})`)});node.on('click', function(event, d) {window.location.href = `/device/${d.id}`})}function getNodeRadius(node) {if (node.isGateway) return 15;if (node.isServer) return 12;return 8}function getNodeColor(node) {const colors = {'up': '#28a745', 'down': '#dc3545', 'warning': '#ffc107', 'unknown': '#6c757d' };return colors[node.status] || colors.unknown}function dragStarted(event, d) {if (!event.active) NetworkTopology.simulation.alphaTarget(0.3).restart();d.fx = d.x;d.fy = d.y}function dragged(event, d) {d.fx = event.x;d.fy = event.y}function dragEnded(event, d) {if (!event.active) NetworkTopology.simulation.alphaTarget(0);d.fx = null;d.fy = null}function updateTopology(devices) {if (!NetworkTopology.initialized || !devices) return;NetworkTopology.nodes.forEach(node => {const device = devices.find(d => d.id === node.id);if (device) {node.status = device.status;node.response_time = device.latest_response_time}});NetworkTopology.svg.selectAll('.node-circle') .attr('fill', d => getNodeColor(d)) .attr('class', d => `node-circle status-${d.status}`);NetworkTopology.svg.selectAll('.node title') .text(d => `${d.name}\n${d.ip}\nStatus: ${d.status}\nResponse: ${d.response_time || 'N/A'}ms`)}function showTopologyError(message) {const container = document.getElementById('network-topology');if (container) {container.innerHTML = `<div class="alert alert-danger">${message}</div>`}}function refreshTopology() {if (NetworkTopology.initialized) {loadNetworkData()}}document.addEventListener('DOMContentLoaded', function() {if (document.getElementById('network-topology')) {initializeNetworkTopology()}});document.addEventListener('device:updated', function(event) {if (event.detail && NetworkTopology.initialized) {const node = NetworkTopology.nodes.find(n => n.id === event.detail.device_id);if (node) {node.status = event.detail.status;node.response_time = event.detail.response_time;NetworkTopology.svg.select(`.node-circle[data-id="${event.detail.device_id}"]`) .attr('fill', getNodeColor(node)) .attr('class', `node-circle status-${node.status}`)}}});window.NetworkTopology.refresh = refreshTopology;window.NetworkTopology.update = updateTopology;