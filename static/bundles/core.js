window.HomeNetMon = {config: {apiBase: '/api', socketConnected: false, autoRefresh: true, refreshInterval: 30000 }, data: {devices: [], alerts: [], lastUpdate: null }, socket: null };document.addEventListener('DOMContentLoaded', function() {console.log('HomeNetMon application initializing...');initializeSocket();initializeGlobalHandlers();if (HomeNetMon.config.autoRefresh) {startAutoRefresh()}console.log('HomeNetMon application initialized')});function initializeSocket() {try {HomeNetMon.socket = io({transports: ['websocket', 'polling'], timeout: 20000 });HomeNetMon.socket.on('connect', function() {console.log('Socket.IO connected');HomeNetMon.config.socketConnected = true;updateConnectionStatus(true)});HomeNetMon.socket.on('disconnect', function() {console.log('Socket.IO disconnected');HomeNetMon.config.socketConnected = false;updateConnectionStatus(false)});HomeNetMon.socket.on('device_status_update', function(data) {updateDeviceStatus(data)});HomeNetMon.socket.on('monitoring_summary', function(data) {updateMonitoringSummary(data)})}catch (error) {console.error('Socket.IO initialization failed:', error)}}function initializeGlobalHandlers() {document.addEventListener('click', function(e) {const link = e.target.closest('[data-nav]');if (link) {e.preventDefault();const url = link.getAttribute('href') || link.getAttribute('data-url');if (url) {window.location.href = url}}});document.addEventListener('click', function(e) {if (e.target.matches('[data-refresh]')) {e.preventDefault();refreshData()}})}function updateConnectionStatus(connected) {const indicators = document.querySelectorAll('[data-connection-status]');indicators.forEach(indicator => {indicator.className = connected ? 'text-success' : 'text-danger';indicator.textContent = connected ? 'Connected' : 'Disconnected'})}function updateDeviceStatus(data) {if (!data || !data.device_id) return;const deviceRows = document.querySelectorAll(`[data-device-id="${data.device_id}"]`);deviceRows.forEach(row => {const statusBadge = row.querySelector('[data-status]');if (statusBadge) {statusBadge.className = `badge bg-${getStatusColor(data.status)}`;statusBadge.textContent = data.status.toUpperCase()}const responseTime = row.querySelector('[data-response-time]');if (responseTime) {responseTime.textContent = data.response_time ? `${data.response_time}ms` : 'N/A'}const lastSeen = row.querySelector('[data-last-seen]');if (lastSeen && data.timestamp) {lastSeen.textContent = formatTimestamp(data.timestamp)}})}function updateMonitoringSummary(data) {if (!data) return;const stats = [ {key: 'total_devices', selector: '[data-stat-total-devices]' }, {key: 'devices_up', selector: '[data-stat-devices-up]' }, {key: 'devices_down', selector: '[data-stat-devices-down]' }, {key: 'active_alerts', selector: '[data-stat-active-alerts]' }];stats.forEach(stat => {const elements = document.querySelectorAll(stat.selector);elements.forEach(el => {el.textContent = data[stat.key] || '0'})});if (data.success_rate !== undefined) {const successElements = document.querySelectorAll('[data-stat-success-rate]');successElements.forEach(el => {el.textContent = `${data.success_rate.toFixed(1)}%`})}}function getStatusColor(status) {const statusColors = {'up': 'success', 'down': 'danger', 'warning': 'warning', 'unknown': 'secondary' };return statusColors[status] || 'secondary'}function formatTimestamp(timestamp) {try {const date = new Date(timestamp);return date.toLocaleString()}catch (error) {return 'Unknown'}}function startAutoRefresh() {setInterval(function() {if (!HomeNetMon.config.socketConnected) {refreshData()}}, HomeNetMon.config.refreshInterval)}function refreshData() {console.log('Refreshing data...');window.location.reload()}function apiCall(endpoint, options = {}) {const url = HomeNetMon.config.apiBase + endpoint;return fetch(url, {headers: {'Content-Type': 'application/json', ...options.headers }, ...options }) .then(response => {if (!response.ok) {throw new Error(`HTTP ${response.status}: ${response.statusText}`)}return response.json()}) .catch(error => {console.error('API call failed:', error);throw error})}window.HomeNetMon.apiCall = apiCall;window.HomeNetMon.updateDeviceStatus = updateDeviceStatus;window.RealTimeUpdates = {socket: null, connected: false, reconnectAttempts: 0, maxReconnectAttempts: 5, subscriptions: new Set(), handlers: {}};function initializeRealTimeUpdates() {console.log('Initializing real-time updates...');if (typeof io === 'undefined') {console.warn('Socket.IO not available, real-time updates disabled');return}connectWebSocket()}function connectWebSocket() {try {RealTimeUpdates.socket = io({transports: ['websocket', 'polling'], timeout: 20000, forceNew: true });setupSocketHandlers()}catch (error) {console.error('WebSocket connection failed:', error);scheduleReconnect()}}function setupSocketHandlers() {const socket = RealTimeUpdates.socket;socket.on('connect', function() {console.log('Real-time updates connected');RealTimeUpdates.connected = true;RealTimeUpdates.reconnectAttempts = 0;updateConnectionIndicator(true);resubscribeToRooms();emitCustomEvent('realtime:connected')});socket.on('disconnect', function(reason) {console.log('Real-time updates disconnected:', reason);RealTimeUpdates.connected = false;updateConnectionIndicator(false);emitCustomEvent('realtime:disconnected', {reason });if (reason !== 'io client disconnect') {scheduleReconnect()}});socket.on('connect_error', function(error) {console.error('Real-time connection error:', error);scheduleReconnect()});socket.on('device_status_update', function(data) {handleDeviceUpdate(data)});socket.on('monitoring_summary', function(data) {handleMonitoringSummary(data)});socket.on('chart_data_update', function(data) {handleChartUpdate(data)});socket.on('alert_update', function(data) {handleAlertUpdate(data)});socket.on('performance_metrics_update', function(data) {handlePerformanceUpdate(data)})}function handleDeviceUpdate(data) {if (!data || !data.device_id) return;console.debug('Device update received:', data);updateDeviceDisplays(data);if (data.status_changed) {requestChartUpdate()}emitCustomEvent('device:updated', data)}function handleMonitoringSummary(data) {if (!data) return;console.debug('Monitoring summary received:', data);updateSummaryDisplays(data);updateNetworkStatus(data);emitCustomEvent('monitoring:summary', data)}function handleChartUpdate(data) {if (!data) return;console.debug('Chart update received:', data);switch (data.type) {case 'network_overview': updateNetworkChart(data);break;case 'response_time': updateResponseTimeChart(data);break;case 'bandwidth': updateBandwidthChart(data);break}emitCustomEvent('chart:updated', data)}function handleAlertUpdate(data) {if (!data) return;console.debug('Alert update received:', data);updateAlertDisplays(data);if (data.type === 'new_alert') {showAlertNotification(data)}emitCustomEvent('alert:updated', data)}function handlePerformanceUpdate(data) {if (!data) return;console.debug('Performance update received:', data);updatePerformanceDisplays(data);emitCustomEvent('performance:updated', data)}function updateDeviceDisplays(data) {const deviceElements = document.querySelectorAll(`[data-device-id="${data.device_id}"]`);deviceElements.forEach(element => {const statusBadge = element.querySelector('[data-device-status]');if (statusBadge) {statusBadge.className = `badge bg-${getStatusColor(data.status)}`;statusBadge.textContent = data.status.toUpperCase()}const responseTime = element.querySelector('[data-device-response-time]');if (responseTime) {responseTime.textContent = data.response_time ? `${data.response_time}ms` : 'N/A'}const lastSeen = element.querySelector('[data-device-last-seen]');if (lastSeen && data.timestamp) {lastSeen.textContent = formatRelativeTime(data.timestamp)}if (data.display_name) {const nameElement = element.querySelector('[data-device-name]');if (nameElement) {nameElement.textContent = data.display_name}}})}function updateSummaryDisplays(data) {const summaryElements = [ {key: 'total_devices', selector: '[data-summary-total]' }, {key: 'devices_up', selector: '[data-summary-up]' }, {key: 'devices_down', selector: '[data-summary-down]' }, {key: 'active_alerts', selector: '[data-summary-alerts]' }, {key: 'success_rate', selector: '[data-summary-success-rate]' }];summaryElements.forEach(item => {const elements = document.querySelectorAll(item.selector);elements.forEach(element => {let value = data[item.key];if (item.key === 'success_rate' && value !== undefined) {value = `${value.toFixed(1)}%`}element.textContent = value || '0'})})}function subscribeToUpdates(room) {if (!RealTimeUpdates.socket || RealTimeUpdates.subscriptions.has(room)) {return}console.log('Subscribing to updates:', room);RealTimeUpdates.socket.emit('join', room);RealTimeUpdates.subscriptions.add(room)}function unsubscribeFromUpdates(room) {if (!RealTimeUpdates.socket || !RealTimeUpdates.subscriptions.has(room)) {return}console.log('Unsubscribing from updates:', room);RealTimeUpdates.socket.emit('leave', room);RealTimeUpdates.subscriptions.delete(room)}function resubscribeToRooms() {RealTimeUpdates.subscriptions.forEach(room => {RealTimeUpdates.socket.emit('join', room)})}function updateConnectionIndicator(connected) {const indicators = document.querySelectorAll('[data-connection-status]');indicators.forEach(indicator => {indicator.className = connected ? 'text-success' : 'text-warning';indicator.textContent = connected ? 'Live' : 'Connecting...';indicator.title = connected ? 'Real-time updates active' : 'Attempting to reconnect...'})}function scheduleReconnect() {if (RealTimeUpdates.reconnectAttempts >= RealTimeUpdates.maxReconnectAttempts) {console.error('Max reconnection attempts reached');updateConnectionIndicator(false);return}RealTimeUpdates.reconnectAttempts++;const delay = Math.min(1000 * Math.pow(2, RealTimeUpdates.reconnectAttempts), 30000);console.log(`Scheduling reconnect attempt ${RealTimeUpdates.reconnectAttempts}in ${delay}ms`);setTimeout(() => {if (!RealTimeUpdates.connected) {connectWebSocket()}}, delay)}function emitCustomEvent(eventName, data = null) {const event = new CustomEvent(eventName, {detail: data });document.dispatchEvent(event)}function showAlertNotification(alertData) {if ('Notification' in window && Notification.permission === 'granted') {new Notification(`HomeNetMon Alert: ${alertData.device_name}`, {body: alertData.message, icon: '/static/favicon.ico' })}}function formatRelativeTime(timestamp) {try {const date = new Date(timestamp);const now = new Date();const diff = now - date;if (diff < 60000) return 'Just now';if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;return `${Math.floor(diff / 86400000)}d ago`}catch (error) {return 'Unknown'}}function requestChartUpdate() {if (!requestChartUpdate.lastRequest || Date.now() - requestChartUpdate.lastRequest > 5000) {requestChartUpdate.lastRequest = Date.now();emitCustomEvent('chart:refresh')}}function getStatusColor(status) {const colors = {'up': 'success', 'down': 'danger', 'warning': 'warning', 'unknown': 'secondary' };return colors[status] || 'secondary'}document.addEventListener('DOMContentLoaded', function() {initializeRealTimeUpdates();setTimeout(() => {subscribeToUpdates('updates_device_status');subscribeToUpdates('updates_monitoring_summary')}, 1000)});window.RealTimeUpdates.subscribe = subscribeToUpdates;window.RealTimeUpdates.unsubscribe = unsubscribeFromUpdates;window.RealTimeUpdates.isConnected = () => RealTimeUpdates.connected;class CSRFHandler {constructor() {this.token = null;this.tokenName = 'csrf_token';this.headerName = 'X-CSRF-Token';this.init()}init() {this.token = this.getTokenFromMeta() || this.getCookie(this.tokenName);this.setupFetchInterceptor();this.setupXHRInterceptor();console.log('🔒 CSRF Handler initialized with token:', this.token ? 'PRESENT' : 'MISSING')}getTokenFromMeta() {const metaToken = document.querySelector('meta[name="csrf-token"]');return metaToken ? metaToken.getAttribute('content') : null}getCookie(name) {const value = `;${document.cookie}`;const parts = value.split(`;${name}=`);if (parts.length === 2) {return parts.pop().split(';').shift()}return null}getToken() {if (!this.token) {this.token = this.getTokenFromMeta() || this.getCookie(this.tokenName)}return this.token}async refreshTokenFromAPI() {try {console.log('🔒 Refreshing CSRF token from API...');const response = await fetch('/api/csrf-token', {method: 'GET', credentials: 'same-origin' });if (!response.ok) {throw new Error(`Token refresh failed: ${response.status}`)}const data = await response.json();this.token = data.csrf_token;let metaTag = document.querySelector('meta[name="csrf-token"]');if (metaTag) {metaTag.setAttribute('content', this.token)}console.log('🔒 CSRF token refreshed successfully');return this.token}catch (error) {console.error('🔒 CSRF token refresh failed:', error);throw error}}setToken(token) {this.token = token}setupFetchInterceptor() {const originalFetch = window.fetch;window.fetch = (url, options = {}) => {if (url.includes('/api/monitoring/alerts')) {console.log('🔍 CSRF Handler - Alerts request:', {url, method: options.method || 'GET', headers: options.headers, requiresToken: this.requiresCSRFToken(options.method || 'GET', url) })}if (this.isSameOrigin(url)) {const token = this.getToken();if (token && this.requiresCSRFToken(options.method || 'GET', url)) {options.headers = {...options.headers, [this.headerName]: token };if (url.includes('/api/monitoring/alerts')) {console.log('🔒 CSRF Handler - Added token to alerts request')}}}if (url.includes('/api/monitoring/alerts')) {console.log('🚀 Making alerts request with options:', {url: url, options: JSON.stringify(options, null, 2) })}return originalFetch(url, options).catch(error => {if (url.includes('/api/monitoring/alerts')) {console.error('🚨 Alerts request failed:', error);console.log('🚨 Failed request details:', {url, options })}throw error})}}setupXHRInterceptor() {const originalOpen = XMLHttpRequest.prototype.open;const originalSend = XMLHttpRequest.prototype.send;XMLHttpRequest.prototype.open = function(method, url, ...args) {this._method = method;this._url = url;return originalOpen.apply(this, [method, url, ...args])};XMLHttpRequest.prototype.send = function(data) {if (window.csrfHandler && window.csrfHandler.isSameOrigin(this._url)) {const token = window.csrfHandler.getToken();if (token && window.csrfHandler.requiresCSRFToken(this._method, this._url)) {this.setRequestHeader(window.csrfHandler.headerName, token)}}return originalSend.apply(this, arguments)}}isSameOrigin(url) {if (!url) return true;if (url.startsWith('/') || !url.includes(': return true}try {const urlObj = new URL(url);return urlObj.origin === window.location.origin}catch (e) {return false}}requiresCSRFToken(method, url = '') {const upperMethod = (method || 'GET').toUpperCase();const exemptPaths = [ '/api/monitoring/alerts', '/api/health', '/api/csrf-token' ];if (exemptPaths.some(path => url.includes(path))) {return false}return ['POST', 'PUT', 'PATCH', 'DELETE'].includes(upperMethod)}addTokenToFormData(formData) {const token = this.getToken();if (token && formData instanceof FormData) {formData.append(this.tokenName, token)}return formData}addTokenToForm(form) {const token = this.getToken();if (token && form instanceof HTMLFormElement) {const existingTokens = form.querySelectorAll(`input[name="${this.tokenName}"]`);existingTokens.forEach(input => input.remove());const tokenInput = document.createElement('input');tokenInput.type = 'hidden';tokenInput.name = this.tokenName;tokenInput.value = token;form.appendChild(tokenInput)}}setupForms() {document.addEventListener('submit', (event) => {const form = event.target;if (form instanceof HTMLFormElement) {this.addTokenToForm(form)}});document.querySelectorAll('form').forEach(form => {this.addTokenToForm(form)})}getHeaders(additionalHeaders = {}) {const token = this.getToken();const headers = {...additionalHeaders };if (token) {headers[this.headerName] = token}return headers}refreshToken() {this.token = this.getTokenFromMeta() || this.getCookie(this.tokenName);return this.token}async handleCSRFError(response) {if (response && (response.status === 403 || response.status === 422)) {try {console.log('🔒 CSRF error detected, attempting automatic token refresh...');await this.refreshTokenFromAPI();return true}catch (error) {console.error('🔒 Automatic token refresh failed:', error);if (window.modernNotifications) {window.modernNotifications.warning('Security token expired. Please refresh the page.', {duration: 5000, actions: [{label: 'Refresh', primary: true, callback: () => window.location.reload() }] })}else {console.warn('CSRF token validation failed. Page refresh may be required.')}return false}}return false}}if (typeof window !== 'undefined') {window.csrfHandler = new CSRFHandler();if (document.readyState === 'loading') {document.addEventListener('DOMContentLoaded', () => {window.csrfHandler.setupForms()})}else {window.csrfHandler.setupForms()}window.getCSRFToken = () => window.csrfHandler.getToken();window.getCSRFHeaders = (headers) => window.csrfHandler.getHeaders(headers)}if (typeof module !== 'undefined' && module.exports) {module.exports = CSRFHandler}class HTMLSanitizer {constructor() {this.allowedTags = {'div': ['class', 'id', 'style', 'data-*'], 'span': ['class', 'id', 'style', 'data-*'], 'p': ['class', 'id', 'style'], 'a': ['href', 'class', 'id', 'target', 'rel'], 'img': ['src', 'alt', 'class', 'id', 'width', 'height'], 'i': ['class', 'id'], 'b': ['class', 'id'], 'strong': ['class', 'id'], 'em': ['class', 'id'], 'small': ['class', 'id'], 'h1': ['class', 'id'], 'h2': ['class', 'id'], 'h3': ['class', 'id'], 'h4': ['class', 'id'], 'h5': ['class', 'id'], 'h6': ['class', 'id'], 'ul': ['class', 'id'], 'ol': ['class', 'id'], 'li': ['class', 'id'], 'table': ['class', 'id'], 'thead': ['class', 'id'], 'tbody': ['class', 'id'], 'tr': ['class', 'id'], 'th': ['class', 'id'], 'td': ['class', 'id'], 'button': ['class', 'id', 'type', 'disabled'], };this.dangerousAttributes = [ 'onclick', 'onload', 'onerror', 'onmouseover', 'onmouseout', 'onfocus', 'onblur', 'onchange', 'onsubmit', 'onkeydown', 'onkeyup', 'onkeypress', 'javascript:', 'vbscript:', 'data:', 'formaction', 'srcdoc' ];this.init()}init() {console.log('🛡️ HTML Sanitizer initialized')}sanitize(html, allowTags = true) {if (typeof html !== 'string') {return ''}if (!allowTags) {return this.escapeHtml(html)}const temp = document.createElement('div');temp.innerHTML = html;this.sanitizeElement(temp);return temp.innerHTML}escapeHtml(text) {const div = document.createElement('div');div.textContent = text;return div.innerHTML}sanitizeElement(element) {const children = Array.from(element.children);for (const child of children) {const tagName = child.tagName.toLowerCase();if (!this.allowedTags[tagName]) {child.remove();continue}this.sanitizeAttributes(child);this.sanitizeElement(child)}}sanitizeAttributes(element) {const tagName = element.tagName.toLowerCase();const allowedAttrs = this.allowedTags[tagName] || [];const attributes = Array.from(element.attributes);for (const attr of attributes) {const attrName = attr.name.toLowerCase();const attrValue = attr.value.toLowerCase();if (this.dangerousAttributes.some(dangerous => attrName.includes(dangerous) || attrValue.includes(dangerous))) {element.removeAttribute(attr.name);continue}const isAllowed = allowedAttrs.some(allowed => {if (allowed.endsWith('*')) {return attrName.startsWith(allowed.slice(0, -1))}return attrName === allowed});if (!isAllowed) {element.removeAttribute(attr.name)}}}setHTML(element, html) {if (!element || !(element instanceof Element)) {console.warn('Invalid element provided to setHTML');return}element.innerHTML = this.sanitize(html)}setText(element, text) {if (!element || !(element instanceof Element)) {console.warn('Invalid element provided to setText');return}element.textContent = String(text || '')}createTextNode(text) {return document.createTextNode(String(text || ''))}sanitizeUrl(url) {if (typeof url !== 'string') {return null}const dangerousProtocols = ['javascript:', 'vbscript:', 'data:', 'file:'];const lowerUrl = url.toLowerCase().trim();if (dangerousProtocols.some(protocol => lowerUrl.startsWith(protocol))) {return null}if (url.startsWith('/') || url.startsWith('./') || url.startsWith('../') || lowerUrl.startsWith('http: lowerUrl.startsWith('mailto:') || lowerUrl.startsWith('tel:')) {return url}return null}html(strings, ...values) {let result = '';for (let i = 0;i < strings.length;i++) {result += strings[i];if (i < values.length) {result += this.escapeHtml(String(values[i]))}}return this.sanitize(result)}createBuilder() {return {div: (content, className = '') => `<div class="${this.escapeHtml(className)}">${this.sanitize(content)}</div>`, span: (content, className = '') => `<span class="${this.escapeHtml(className)}">${this.sanitize(content)}</span>`, p: (content, className = '') => `<p class="${this.escapeHtml(className)}">${this.sanitize(content)}</p>`, button: (content, className = '', type = 'button') => `<button type="${this.escapeHtml(type)}" class="${this.escapeHtml(className)}">${this.sanitize(content)}</button>`, link: (text, href, className = '') => {const safeHref = this.sanitizeUrl(href);if (!safeHref) return this.escapeHtml(text);return `<a href="${this.escapeHtml(safeHref)}" class="${this.escapeHtml(className)}">${this.escapeHtml(text)}</a>`}, icon: (iconClass, className = '') => `<i class="${this.escapeHtml(iconClass)}${this.escapeHtml(className)}"></i>` }}}if (typeof window !== 'undefined') {window.htmlSanitizer = new HTMLSanitizer();window.safeHTML = (element, html) => window.htmlSanitizer.setHTML(element, html);window.safeText = (element, text) => window.htmlSanitizer.setText(element, text);window.escapeHTML = (text) => window.htmlSanitizer.escapeHtml(text);window.sanitizeHTML = (html) => window.htmlSanitizer.sanitize(html);window.html = (strings, ...values) => window.htmlSanitizer.html(strings, ...values);if (window.location.hostname !== 'localhost' && !window.location.hostname.startsWith('192.168.')) {const originalInnerHTML = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');Object.defineProperty(Element.prototype, 'innerHTML', {set: function(value) {if (typeof value === 'string' && value.includes('<') && !this.dataset.allowUnsafeHTML) {console.warn( 'Potentially unsafe innerHTML usage detected. Consider using safeHTML() instead.', this, value )}return originalInnerHTML.set.call(this, value)}, get: function() {return originalInnerHTML.get.call(this)}})}}if (typeof module !== 'undefined' && module.exports) {module.exports = HTMLSanitizer}