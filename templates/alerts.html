{% extends "base_beautiful.html" %}

{% block title %}Alerts - HomeNetMon{% endblock %}

{% block extra_css %}
<style>
/* Alerts-specific styles */

/* Controls Section */
.controls-section {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 2rem;
    align-items: center;
    margin-bottom: 2rem;
    background: rgba(255, 255, 255, 0.02);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 1.5rem;
}

.search-filter-section {
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
}

.search-box {
    position: relative;
    flex: 1;
    min-width: 200px;
}

.search-box input {
    width: 100%;
    padding: 0.75rem 1rem 0.75rem 2.5rem;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    color: #e0e0e0;
    font-size: 0.95rem;
}

.search-box input:focus {
    outline: none;
    border-color: rgba(59, 130, 246, 0.5);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.search-box .search-icon {
    position: absolute;
    left: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    color: #888;
}

.filter-controls {
    display: flex;
    gap: 1rem;
    align-items: center;
}

.filter-select {
    padding: 0.6rem 1rem;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    color: #e0e0e0;
    font-size: 0.9rem;
}

.filter-select:focus {
    outline: none;
    border-color: rgba(59, 130, 246, 0.5);
}

.action-buttons {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
}

/* Special styling for Delete ALL button - more prominent */
.btn-danger-bold {
    background: linear-gradient(135deg, #dc3545, #b02a37);
    border: 2px solid #dc3545;
    color: white;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 0.85rem;
    letter-spacing: 0.5px;
}

.btn-danger-bold:hover {
    background: linear-gradient(135deg, #c82333, #a02026);
    border-color: #c82333;
    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
    transform: translateY(-1px);
}

/* Dropdown styling for bulk delete options */
.dropdown-menu-dark {
    background-color: rgba(33, 37, 41, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.15);
}

.dropdown-menu-dark .dropdown-item {
    color: #e0e0e0;
}

.dropdown-menu-dark .dropdown-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
    color: #fff;
}

/* Alerts Grid */
.alerts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
}

.alert-card {
    background: rgba(255, 255, 255, 0.02);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 1.5rem;
    transition: all 0.3s ease;
    position: relative;
}

.alert-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
    border-color: rgba(255, 255, 255, 0.2);
}

.alert-card.critical {
    border-left: 4px solid #ff4757;
    box-shadow: 0 0 20px rgba(255, 71, 87, 0.1);
}

.alert-card.high {
    border-left: 4px solid #ff9800;
    box-shadow: 0 0 20px rgba(255, 152, 0, 0.1);
}

.alert-card.medium {
    border-left: 4px solid #ffc107;
    box-shadow: 0 0 20px rgba(255, 193, 7, 0.1);
}

.alert-card.low {
    border-left: 4px solid #28a745;
    box-shadow: 0 0 20px rgba(40, 167, 69, 0.1);
}

.alert-card.resolved {
    opacity: 0.6;
    border-left: 4px solid #6c757d;
}

.alert-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1rem;
}

.alert-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #e0e0e0;
    margin-bottom: 0.25rem;
}

.alert-device {
    font-size: 0.9rem;
    color: #888;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.alert-status {
    display: flex;
    gap: 0.5rem;
    align-items: center;
}

.status-badge {
    padding: 0.25rem 0.75rem;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.status-badge.critical {
    background: rgba(255, 71, 87, 0.2);
    color: #ff4757;
    border: 1px solid rgba(255, 71, 87, 0.3);
}

.status-badge.high {
    background: rgba(255, 152, 0, 0.2);
    color: #ff9800;
    border: 1px solid rgba(255, 152, 0, 0.3);
}

.status-badge.medium {
    background: rgba(255, 193, 7, 0.2);
    color: #ffc107;
    border: 1px solid rgba(255, 193, 7, 0.3);
}

.status-badge.low {
    background: rgba(40, 167, 69, 0.2);
    color: #28a745;
    border: 1px solid rgba(40, 167, 69, 0.3);
}

.status-badge.resolved {
    background: rgba(108, 117, 125, 0.2);
    color: #6c757d;
    border: 1px solid rgba(108, 117, 125, 0.3);
}

.alert-timestamp {
    font-size: 0.8rem;
    color: #666;
    display: flex;
    align-items: center;
    gap: 0.25rem;
}

.alert-content {
    margin-bottom: 1rem;
}

.alert-message {
    font-size: 0.95rem;
    line-height: 1.5;
    color: #b0b0b0;
}

.alert-actions {
    display: flex;
    gap: 0.5rem;
    justify-content: flex-end;
}

.alert-actions .btn {
    padding: 0.4rem 0.8rem;
    font-size: 0.8rem;
}

/* Empty States */
.empty-state {
    text-align: center;
    padding: 4rem 2rem;
    color: #888;
}

.empty-state i {
    font-size: 4rem;
    color: #666;
    margin-bottom: 1rem;
    display: block;
}

.empty-state h3 {
    font-size: 1.5rem;
    color: #b0b0b0;
    margin-bottom: 0.5rem;
}

.empty-state p {
    font-size: 1rem;
    margin-bottom: 1.5rem;
}

/* Loading Animation */
.loading-spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: white;
    animation: spin 1s ease-in-out infinite;
}

/* Checkbox styling */
.alert-checkbox {
    position: absolute;
    top: 1rem;
    left: 1rem;
    width: 18px;
    height: 18px;
    accent-color: rgba(59, 130, 246, 0.8);
}

.alert-card.selected {
    border-color: rgba(59, 130, 246, 0.5);
    background: rgba(59, 130, 246, 0.05);
}

/* Toast Notifications */
.toast-container {
    position: fixed;
    top: 100px;
    right: 20px;
    z-index: 9999;
    max-width: 400px;
}

.toast {
    background: rgba(0, 0, 0, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 1rem 1.5rem;
    margin-bottom: 0.5rem;
    color: white;
    font-size: 0.9rem;
    opacity: 0;
    transform: translateX(100%);
    transition: all 0.3s ease;
}

.toast.show {
    opacity: 1;
    transform: translateX(0);
}

.toast.success {
    border-left: 4px solid #28a745;
}

.toast.warning {
    border-left: 4px solid #ffc107;
}

.toast.error {
    border-left: 4px solid #dc3545;
}

.toast.info {
    border-left: 4px solid #17a2b8;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .controls-section {
        grid-template-columns: 1fr;
        gap: 1rem;
    }

    .alerts-grid {
        grid-template-columns: 1fr;
    }

    .search-filter-section {
        flex-direction: column;
        align-items: stretch;
    }

    .action-buttons {
        justify-content: center;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="page-header">
    <h1 class="page-title">Network Alerts</h1>
    <p class="page-subtitle">Monitor and manage network device alerts</p>
    <div class="page-version">v1.0.0</div>
</div>

<div class="controls-section">
    <div class="search-filter-section">
        <div class="search-box">
            <i class="bi bi-search search-icon"></i>
            <input type="text" id="search-input" placeholder="Search alerts..." autocomplete="off">
        </div>
        <div class="filter-controls">
            <select id="severity-filter" class="filter-select">
                <option value="">All Severities</option>
                <option value="critical">Critical</option>
                <option value="high">High</option>
                <option value="medium">Medium</option>
                <option value="low">Low</option>
            </select>
            <select id="status-filter" class="filter-select">
                <option value="">All Statuses</option>
                <option value="active">Active</option>
                <option value="resolved">Resolved</option>
            </select>
            <select id="time-filter" class="filter-select">
                <option value="">All Time</option>
                <option value="1h">Last Hour</option>
                <option value="24h">Last 24 Hours</option>
                <option value="7d">Last 7 Days</option>
                <option value="30d">Last 30 Days</option>
            </select>
        </div>
    </div>
    <div class="action-buttons">
        <button class="btn-modern btn-secondary" onclick="selectAllAlerts()" id="select-all-btn">
            <i class="bi bi-check2-square"></i>
            Select All
        </button>
        <button class="btn-modern btn-warning" onclick="resolveSelectedAlerts()" id="resolve-btn" disabled>
            <i class="bi bi-check-circle"></i>
            Resolve Selected
        </button>
        <button class="btn-modern btn-danger" onclick="deleteSelectedAlerts()" id="delete-btn" disabled>
            <i class="bi bi-trash"></i>
            Delete Selected
        </button>
        <button class="btn-modern btn-danger-bold" onclick="deleteAllAlerts()" id="delete-all-btn" title="Delete ALL alerts - Use with caution!">
            <i class="bi bi-trash3"></i>
            Delete ALL Alerts
        </button>
        <div class="dropdown" style="display: inline-block;">
            <button class="btn-modern btn-danger dropdown-toggle" type="button" id="bulkDeleteDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                <i class="bi bi-funnel"></i>
                Bulk Delete
            </button>
            <ul class="dropdown-menu dropdown-menu-dark" aria-labelledby="bulkDeleteDropdown">
                <li><a class="dropdown-item" href="#" onclick="bulkDeleteByType('performance')">Delete All Performance Alerts</a></li>
                <li><a class="dropdown-item" href="#" onclick="bulkDeleteByType('device_recovery')">Delete All Recovery Alerts</a></li>
                <li><a class="dropdown-item" href="#" onclick="bulkDeleteByStatus(true)">Delete All Resolved Alerts</a></li>
                <li><a class="dropdown-item" href="#" onclick="bulkDeleteByStatus(false)">Delete All Unresolved Alerts</a></li>
                <li><hr class="dropdown-divider"></li>
                <li><a class="dropdown-item text-warning" href="#" onclick="bulkDeleteBySeverity('info')">Delete All Info Alerts</a></li>
                <li><a class="dropdown-item text-danger" href="#" onclick="bulkDeleteBySeverity('warning')">Delete All Warning Alerts</a></li>
            </ul>
        </div>
        <button class="btn-modern btn-primary" onclick="refreshAlerts()">
            <i class="bi bi-arrow-clockwise"></i>
            Refresh
        </button>
    </div>
</div>

<div id="alerts-container">
    <!-- Loading State -->
    <div id="loading-state" class="empty-state">
        <i class="bi bi-hourglass-split loading-spinner"></i>
        <h3>Loading Alerts</h3>
        <p>Fetching network alerts...</p>
    </div>

    <!-- Alerts Grid -->
    <div id="alerts-grid" class="alerts-grid hidden">
        <!-- Alert cards will be dynamically inserted here -->
    </div>

    <!-- No Alerts State -->
    <div id="no-alerts-state" class="empty-state hidden">
        <i class="bi bi-shield-check"></i>
        <h3>No Alerts</h3>
        <p>Your network is running smoothly! No alerts to display.</p>
        <button class="btn-modern btn-primary" onclick="refreshAlerts()">
            <i class="bi bi-arrow-clockwise"></i>
            Refresh
        </button>
    </div>

    <!-- Error State -->
    <div id="error-state" class="empty-state hidden">
        <i class="bi bi-exclamation-circle"></i>
        <h3>Error Loading Alerts</h3>
        <p id="error-message">Unable to load alerts. Please try again.</p>
        <button class="btn-modern btn-primary" onclick="loadAlerts()">
            <i class="bi bi-arrow-clockwise"></i>
            Retry
        </button>
    </div>
</div>

<!-- Toast Container -->
<div id="toast-container" class="toast-container"></div>
{% endblock %}

{% block extra_js %}
<script>
class AlertsManager {
    constructor() {
        this.alerts = [];
        this.filteredAlerts = [];
        this.selectedAlerts = new Set();
        this.socket = null;
        this.isLoading = false;
        this.loadingTimeout = null;
        this.retryCount = 0;
        this.maxRetries = 3;
        this.retryDelay = 1000; // Start with 1 second
        this.debugMode = localStorage.getItem('alerts_debug') === 'true';

        this.debug('AlertsManager initialized');
        this.initializeSocketIO();
        this.bindEvents();
        this.loadAlerts();

        // Set up automatic timeout protection
        this.setupLoadingTimeoutProtection();
    }

    debug(message, data = null) {
        if (this.debugMode) {
            const timestamp = new Date().toISOString();
            console.log(`[AlertsManager ${timestamp}] ${message}`, data || '');
        }
    }

    setupLoadingTimeoutProtection() {
        // Clear any existing timeout
        if (this.loadingTimeout) {
            clearTimeout(this.loadingTimeout);
        }

        // Set a 30-second timeout to automatically clear loading state
        this.loadingTimeout = setTimeout(() => {
            this.debug('Loading timeout reached - forcing clear loading state');
            this.isLoading = false;
            this.showLoadingState(false);
            this.showToast('Loading took longer than expected. Please try refreshing.', 'warning', 10000);
        }, 30000);
    }

    initializeSocketIO() {
        try {
            this.debug('Initializing WebSocket connection');

            // Check if Socket.IO is available
            if (typeof io === 'undefined') {
                this.debug('Socket.IO not available - real-time updates disabled');
                this.showToast('Real-time updates unavailable (Socket.IO not loaded)', 'info', 5000);
                return;
            }

            this.socket = io({
                timeout: 10000,
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionAttempts: 5,
                maxReconnectionAttempts: 5
            });

            this.socket.on('connect', () => {
                this.debug('WebSocket connected successfully');
                this.showToast('Real-time updates active', 'success', 2000);
            });

            this.socket.on('disconnect', (reason) => {
                this.debug('WebSocket disconnected:', reason);
                if (reason !== 'io client disconnect') { // Don't show toast for intentional disconnects
                    this.showToast('Real-time updates disconnected', 'warning', 3000);
                }
            });

            this.socket.on('reconnect', (attemptNumber) => {
                this.debug(`WebSocket reconnected after ${attemptNumber} attempts`);
                this.showToast('Real-time updates restored', 'success', 2000);
            });

            this.socket.on('reconnect_attempt', (attemptNumber) => {
                this.debug(`WebSocket reconnection attempt ${attemptNumber}`);
            });

            this.socket.on('reconnect_error', (error) => {
                this.debug('WebSocket reconnection error:', error);
            });

            this.socket.on('reconnect_failed', () => {
                this.debug('WebSocket reconnection failed after maximum attempts');
                this.showToast('Unable to restore real-time updates', 'error', 5000);
            });

            // Listen for alert events
            this.socket.on('alert_created', (alert) => {
                this.debug('Received alert_created event:', alert);
                this.handleNewAlert(alert);
            });

            this.socket.on('alert_updated', (alert) => {
                this.debug('Received alert_updated event:', alert);
                this.handleUpdatedAlert(alert);
            });

            this.socket.on('alert_resolved', (alertId) => {
                this.debug('Received alert_resolved event:', alertId);
                this.handleResolvedAlert(alertId);
            });

        } catch (error) {
            this.debug('Socket.IO initialization error:', error);
            this.showToast('Failed to initialize real-time updates', 'warning', 3000);
        }
    }

    bindEvents() {
        // Search input
        const searchInput = document.getElementById('search-input');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                this.filterAlerts();
            });
        }

        // Filter selects
        const filters = ['severity-filter', 'status-filter', 'time-filter'];
        filters.forEach(filterId => {
            const element = document.getElementById(filterId);
            if (element) {
                element.addEventListener('change', () => {
                    this.filterAlerts();
                });
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'a':
                        e.preventDefault();
                        this.selectAllAlerts();
                        break;
                    case 'r':
                        e.preventDefault();
                        this.refreshAlerts();
                        break;
                }
            }
        });
    }

    async loadAlerts() {
        if (this.isLoading) {
            this.debug('Load already in progress, skipping');
            return;
        }

        this.isLoading = true;
        this.retryCount++;
        this.debug(`Loading alerts (attempt ${this.retryCount})`);

        this.showLoadingState(true);
        this.setupLoadingTimeoutProtection();

        try {
            const response = await fetch('/api/monitoring/alerts', {
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            this.debug('Alerts loaded successfully:', { count: data.alerts?.length || 0 });

            this.alerts = data.alerts || [];
            this.retryCount = 0; // Reset retry count on success
            this.filterAlerts();
            this.showLoadingState(false);

        } catch (error) {
            this.debug('Error loading alerts:', error);
            this.handleLoadError(error);
        } finally {
            this.isLoading = false;
            // Clear timeout since loading completed
            if (this.loadingTimeout) {
                clearTimeout(this.loadingTimeout);
                this.loadingTimeout = null;
            }
        }
    }

    handleLoadError(error) {
        this.showLoadingState(false);

        if (this.retryCount < this.maxRetries) {
            const delay = this.retryDelay * Math.pow(2, this.retryCount - 1); // Exponential backoff
            this.debug(`Retrying in ${delay}ms (attempt ${this.retryCount}/${this.maxRetries})`);

            this.showToast(`Loading failed, retrying in ${delay/1000}s...`, 'warning', delay);

            setTimeout(() => {
                this.loadAlerts();
            }, delay);
        } else {
            this.debug('Max retries reached, showing error state');
            this.showErrorState(`Failed to load alerts: ${error.message}`);
            this.showToast('Failed to load alerts after multiple attempts', 'error', 5000);
        }
    }

    showLoadingState(show) {
        const loadingState = document.getElementById('loading-state');
        const alertsGrid = document.getElementById('alerts-grid');
        const noAlertsState = document.getElementById('no-alerts-state');
        const errorState = document.getElementById('error-state');

        if (show) {
            loadingState.classList.remove('hidden');
            alertsGrid.classList.add('hidden');
            noAlertsState.classList.add('hidden');
            errorState.classList.add('hidden');
        } else {
            loadingState.classList.add('hidden');
        }
    }

    showErrorState(message) {
        const loadingState = document.getElementById('loading-state');
        const alertsGrid = document.getElementById('alerts-grid');
        const noAlertsState = document.getElementById('no-alerts-state');
        const errorState = document.getElementById('error-state');
        const errorMessage = document.getElementById('error-message');

        loadingState.classList.add('hidden');
        alertsGrid.classList.add('hidden');
        noAlertsState.classList.add('hidden');
        errorState.classList.remove('hidden');

        if (errorMessage) {
            errorMessage.textContent = message;
        }
    }

    filterAlerts() {
        const searchTerm = document.getElementById('search-input')?.value.toLowerCase() || '';
        const severityFilter = document.getElementById('severity-filter')?.value || '';
        const statusFilter = document.getElementById('status-filter')?.value || '';
        const timeFilter = document.getElementById('time-filter')?.value || '';

        this.filteredAlerts = this.alerts.filter(alert => {
            // Search filter
            if (searchTerm) {
                const searchableText = `
                    ${alert.title || ''}
                    ${alert.message || ''}
                    ${alert.device_name || ''}
                    ${alert.device_ip || ''}
                `.toLowerCase();

                if (!searchableText.includes(searchTerm)) {
                    return false;
                }
            }

            // Severity filter
            if (severityFilter && alert.severity !== severityFilter) {
                return false;
            }

            // Status filter
            if (statusFilter) {
                const isResolved = alert.resolved_at !== null;
                if (statusFilter === 'active' && isResolved) return false;
                if (statusFilter === 'resolved' && !isResolved) return false;
            }

            // Time filter
            if (timeFilter) {
                const alertTime = new Date(alert.created_at);
                const now = new Date();
                const timeLimit = this.getTimeLimit(timeFilter);

                if (now - alertTime > timeLimit) {
                    return false;
                }
            }

            return true;
        });

        this.renderAlerts();
    }

    getTimeLimit(timeFilter) {
        const timeMap = {
            '1h': 60 * 60 * 1000,
            '24h': 24 * 60 * 60 * 1000,
            '7d': 7 * 24 * 60 * 60 * 1000,
            '30d': 30 * 24 * 60 * 60 * 1000
        };
        return timeMap[timeFilter] || Infinity;
    }

    renderAlerts() {
        const alertsGrid = document.getElementById('alerts-grid');
        const noAlertsState = document.getElementById('no-alerts-state');
        const loadingState = document.getElementById('loading-state');
        const errorState = document.getElementById('error-state');

        // Hide all states first
        loadingState.classList.add('hidden');
        errorState.classList.add('hidden');

        if (this.filteredAlerts.length === 0) {
            alertsGrid.classList.add('hidden');
            noAlertsState.classList.remove('hidden');
            return;
        }

        noAlertsState.classList.add('hidden');
        alertsGrid.classList.remove('hidden');
        alertsGrid.style.display = 'grid';

        alertsGrid.innerHTML = this.filteredAlerts.map(alert => this.renderAlertCard(alert)).join('');

        // Update selection UI
        this.updateSelectionUI();
    }

    renderAlertCard(alert) {
        const isResolved = alert.resolved_at !== null;
        const resolvedClass = isResolved ? 'resolved' : '';
        const timeAgo = this.getTimeAgo(alert.created_at);

        return `
            <div class="alert-card ${alert.severity} ${resolvedClass}" data-alert-id="${alert.id}">
                <input type="checkbox" class="alert-checkbox" onchange="alertsManager.toggleAlert(${alert.id})">

                <div class="alert-header">
                    <div>
                        <div class="alert-title">${this.escapeHtml(alert.title || 'Network Alert')}</div>
                        <div class="alert-device">
                            <i class="bi bi-router"></i>
                            ${this.escapeHtml(alert.device_name || alert.device_ip || 'Unknown Device')}
                        </div>
                    </div>
                    <div class="alert-status">
                        <span class="status-badge ${alert.severity}">${alert.severity.toUpperCase()}</span>
                        ${isResolved ? '<span class="status-badge resolved">RESOLVED</span>' : ''}
                    </div>
                </div>

                <div class="alert-content">
                    <div class="alert-message">${this.escapeHtml(alert.message || 'No additional details available.')}</div>
                </div>

                <div class="alert-timestamp">
                    <i class="bi bi-clock"></i>
                    ${timeAgo}
                    ${isResolved ? `<span class="text-muted">‚Ä¢ Resolved ${this.getTimeAgo(alert.resolved_at)}</span>` : ''}
                </div>

                <div class="alert-actions">
                    ${!isResolved ? `
                        <button class="btn-modern btn-warning" onclick="alertsManager.resolveAlert(${alert.id})">
                            <i class="bi bi-check-circle"></i>
                            Resolve
                        </button>
                    ` : ''}
                    <button class="btn-modern btn-danger" onclick="alertsManager.deleteAlert(${alert.id})">
                        <i class="bi bi-trash"></i>
                        Delete
                    </button>
                </div>
            </div>
        `;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    getTimeAgo(timestamp) {
        const now = new Date();
        const time = new Date(timestamp);
        const diffInSeconds = Math.floor((now - time) / 1000);

        if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
        if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
        if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
        return `${Math.floor(diffInSeconds / 86400)}d ago`;
    }

    toggleAlert(alertId) {
        if (this.selectedAlerts.has(alertId)) {
            this.selectedAlerts.delete(alertId);
        } else {
            this.selectedAlerts.add(alertId);
        }
        this.updateSelectionUI();
    }

    updateSelectionUI() {
        // Update action buttons
        const resolveBtn = document.getElementById('resolve-btn');
        const deleteBtn = document.getElementById('delete-btn');
        const selectAllBtn = document.getElementById('select-all-btn');
        const hasSelection = this.selectedAlerts.size > 0;

        if (resolveBtn) resolveBtn.disabled = !hasSelection;
        if (deleteBtn) deleteBtn.disabled = !hasSelection;

        // Update select all button text and icon
        if (selectAllBtn) {
            const allSelected = this.filteredAlerts.length > 0 && this.selectedAlerts.size === this.filteredAlerts.length;
            if (allSelected) {
                selectAllBtn.innerHTML = '<i class="bi bi-square"></i> Deselect All';
            } else {
                selectAllBtn.innerHTML = '<i class="bi bi-check2-square"></i> Select All';
            }
        }

        // Update card selection visual state
        document.querySelectorAll('.alert-card').forEach(card => {
            const alertId = parseInt(card.dataset.alertId);
            const checkbox = card.querySelector('.alert-checkbox');
            const isSelected = this.selectedAlerts.has(alertId);

            if (checkbox) checkbox.checked = isSelected;
            card.classList.toggle('selected', isSelected);
        });
    }

    selectAllAlerts() {
        // Select all currently visible alerts (regardless of resolution status)
        // This makes the button behavior more intuitive - it selects what the user can see
        const visibleAlerts = this.filteredAlerts;

        if (this.selectedAlerts.size === visibleAlerts.length && visibleAlerts.length > 0) {
            // Deselect all
            this.selectedAlerts.clear();
        } else {
            // Select all visible alerts
            visibleAlerts.forEach(alert => this.selectedAlerts.add(alert.id));
        }

        this.updateSelectionUI();
    }

    async resolveAlert(alertId) {
        try {
            const response = await fetch(`/api/monitoring/alerts/${alertId}/resolve`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            this.showToast('Alert resolved successfully', 'success');
            this.selectedAlerts.delete(alertId);
            this.loadAlerts(); // Refresh to get updated data

        } catch (error) {
            this.debug('Error resolving alert:', error);
            this.showToast(`Failed to resolve alert: ${error.message}`, 'error');
        }
    }

    async resolveSelectedAlerts() {
        if (this.selectedAlerts.size === 0) return;

        const alertIds = Array.from(this.selectedAlerts);
        try {
            const promises = alertIds.map(id => this.resolveAlert(id));
            await Promise.all(promises);

            this.showToast(`Resolved ${alertIds.length} alert(s)`, 'success');
            this.selectedAlerts.clear();
            this.updateSelectionUI();

        } catch (error) {
            this.debug('Error resolving selected alerts:', error);
            this.showToast('Some alerts could not be resolved', 'warning');
        }
    }

    async deleteAlert(alertId) {
        if (!confirm('Are you sure you want to delete this alert? This action cannot be undone.')) {
            return;
        }

        try {
            const response = await fetch(`/api/monitoring/alerts/${alertId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            this.showToast('Alert deleted successfully', 'success');
            this.selectedAlerts.delete(alertId);
            this.loadAlerts(); // Refresh to get updated data

        } catch (error) {
            this.debug('Error deleting alert:', error);
            this.showToast(`Failed to delete alert: ${error.message}`, 'error');
        }
    }

    async deleteSelectedAlerts() {
        if (this.selectedAlerts.size === 0) return;

        const alertCount = this.selectedAlerts.size;
        if (!confirm(`Are you sure you want to delete ${alertCount} alert(s)? This action cannot be undone.`)) {
            return;
        }

        const alertIds = Array.from(this.selectedAlerts);
        try {
            const promises = alertIds.map(id =>
                fetch(`/api/monitoring/alerts/${id}`, { method: 'DELETE' })
            );
            await Promise.all(promises);

            this.showToast(`Deleted ${alertIds.length} alert(s)`, 'success');
            this.selectedAlerts.clear();
            this.updateSelectionUI();
            this.loadAlerts();

        } catch (error) {
            this.debug('Error deleting selected alerts:', error);
            this.showToast('Some alerts could not be deleted', 'warning');
        }
    }

    refreshAlerts() {
        this.debug('Manual refresh requested');
        this.retryCount = 0; // Reset retry count for manual refresh
        this.loadAlerts();
    }

    handleNewAlert(alert) {
        this.alerts.unshift(alert); // Add to beginning
        this.filterAlerts();
        this.showToast(`New ${alert.severity} alert: ${alert.title}`, 'warning', 5000);
    }

    handleUpdatedAlert(alert) {
        const index = this.alerts.findIndex(a => a.id === alert.id);
        if (index !== -1) {
            this.alerts[index] = alert;
            this.filterAlerts();
        }
    }

    handleResolvedAlert(alertId) {
        const alert = this.alerts.find(a => a.id === alertId);
        if (alert) {
            alert.resolved_at = new Date().toISOString();
            this.selectedAlerts.delete(alertId);
            this.filterAlerts();
            this.showToast('Alert resolved', 'success');
        }
    }

    showToast(message, type = 'info', duration = 3000) {
        const container = document.getElementById('toast-container');
        if (!container) return;

        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <i class="bi bi-${this.getToastIcon(type)}"></i>
                <span>${message}</span>
            </div>
        `;

        container.appendChild(toast);

        // Trigger animation
        setTimeout(() => toast.classList.add('show'), 100);

        // Auto remove
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 300);
        }, duration);
    }

    getToastIcon(type) {
        const icons = {
            success: 'check-circle',
            warning: 'exclamation-triangle',
            error: 'x-circle',
            info: 'info-circle'
        };
        return icons[type] || 'info-circle';
    }

    // Debug helper functions
    getDebugInfo() {
        return {
            alerts: this.alerts.length,
            filtered: this.filteredAlerts.length,
            selected: this.selectedAlerts.size,
            isLoading: this.isLoading,
            retryCount: this.retryCount,
            socketConnected: this.socket?.connected || false
        };
    }
}

// Global functions for button actions
function selectAllAlerts() {
    if (window.alertsManager) {
        window.alertsManager.selectAllAlerts();
    }
}

function resolveSelectedAlerts() {
    if (window.alertsManager) {
        window.alertsManager.resolveSelectedAlerts();
    }
}

function deleteSelectedAlerts() {
    if (window.alertsManager) {
        window.alertsManager.deleteSelectedAlerts();
    }
}

function refreshAlerts() {
    if (window.alertsManager) {
        window.alertsManager.refreshAlerts();
    }
}

async function deleteAllAlerts() {
    // Multiple confirmation layers for safety
    const totalAlerts = window.alertsManager ? window.alertsManager.alerts.length : 0;

    if (totalAlerts === 0) {
        alert('No alerts to delete.');
        return;
    }

    // First confirmation
    const firstConfirm = confirm(
        `‚ö†Ô∏è WARNING: This will permanently delete ALL ${totalAlerts} alerts!\n\n` +
        `This action cannot be undone.\n\n` +
        `Are you sure you want to continue?`
    );

    if (!firstConfirm) return;

    // Second confirmation with typing requirement
    const typeConfirm = prompt(
        `üö® FINAL CONFIRMATION üö®\n\n` +
        `To proceed with deleting ALL ${totalAlerts} alerts, type: DELETE ALL ALERTS\n\n` +
        `Type exactly: "DELETE ALL ALERTS" (without quotes):`
    );

    if (typeConfirm !== 'DELETE ALL ALERTS') {
        alert('Deletion cancelled. Text did not match exactly.');
        return;
    }

    try {
        const response = await fetch('/api/monitoring/alerts/delete-all', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('meta[name=csrf-token]')?.content || ''
            },
            body: JSON.stringify({ confirm: true })
        });

        const result = await response.json();

        if (response.ok) {
            alert(`‚úÖ Success: ${result.message}\nAlert generation paused for ${result.alert_generation_paused}`);
            // Refresh the alerts list
            if (window.alertsManager) {
                window.alertsManager.refreshAlerts();
            }
        } else {
            throw new Error(result.error || 'Failed to delete alerts');
        }
    } catch (error) {
        console.error('Error deleting all alerts:', error);
        alert(`‚ùå Error: Failed to delete alerts. ${error.message}`);
    }
}

async function bulkDeleteByType(alertType) {
    const displayName = alertType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());

    const confirm = window.confirm(
        `Delete all "${displayName}" alerts?\n\n` +
        `This will permanently delete all alerts of this type.`
    );

    if (!confirm) return;

    try {
        const response = await fetch('/api/monitoring/alerts/bulk-delete', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('meta[name=csrf-token]')?.content || ''
            },
            body: JSON.stringify({ alert_type: alertType })
        });

        const result = await response.json();

        if (response.ok) {
            alert(`‚úÖ ${result.message}\nAlert generation paused for ${result.alert_generation_paused}`);
            if (window.alertsManager) {
                window.alertsManager.refreshAlerts();
            }
        } else {
            throw new Error(result.error || 'Failed to delete alerts');
        }
    } catch (error) {
        console.error('Error in bulk delete:', error);
        alert(`‚ùå Error: ${error.message}`);
    }
}

async function bulkDeleteByStatus(resolved) {
    const statusText = resolved ? 'resolved' : 'unresolved';

    const confirm = window.confirm(
        `Delete all ${statusText} alerts?\n\n` +
        `This will permanently delete all ${statusText} alerts.`
    );

    if (!confirm) return;

    try {
        const response = await fetch('/api/monitoring/alerts/bulk-delete', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('meta[name=csrf-token]')?.content || ''
            },
            body: JSON.stringify({ resolved: resolved })
        });

        const result = await response.json();

        if (response.ok) {
            alert(`‚úÖ ${result.message}\nAlert generation paused for ${result.alert_generation_paused}`);
            if (window.alertsManager) {
                window.alertsManager.refreshAlerts();
            }
        } else {
            throw new Error(result.error || 'Failed to delete alerts');
        }
    } catch (error) {
        console.error('Error in bulk delete:', error);
        alert(`‚ùå Error: ${error.message}`);
    }
}

async function bulkDeleteBySeverity(severity) {
    const confirm = window.confirm(
        `Delete all "${severity}" severity alerts?\n\n` +
        `This will permanently delete all alerts with ${severity} severity.`
    );

    if (!confirm) return;

    try {
        const response = await fetch('/api/monitoring/alerts/bulk-delete', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('meta[name=csrf-token]')?.content || ''
            },
            body: JSON.stringify({ severity: severity })
        });

        const result = await response.json();

        if (response.ok) {
            alert(`‚úÖ ${result.message}\nAlert generation paused for ${result.alert_generation_paused}`);
            if (window.alertsManager) {
                window.alertsManager.refreshAlerts();
            }
        } else {
            throw new Error(result.error || 'Failed to delete alerts');
        }
    } catch (error) {
        console.error('Error in bulk delete:', error);
        alert(`‚ùå Error: ${error.message}`);
    }
}

function loadAlerts() {
    if (window.alertsManager) {
        window.alertsManager.loadAlerts();
    }
}

function enableDebugMode() {
    localStorage.setItem('alerts_debug', 'true');
    console.log('üêõ Alerts Debug Mode Enabled');
    console.log('Use getDebugInfo() to see current state');
    console.log('Use disableDebugMode() to turn off debug mode');
}

function disableDebugMode() {
    localStorage.removeItem('alerts_debug');
    console.log('üêõ Alerts Debug Mode Disabled');
}

function getDebugInfo() {
    if (window.alertsManager) {
        return window.alertsManager.getDebugInfo();
    }
    return null;
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    let alertsManager;

    try {
        console.log('üöÄ Initializing AlertsManager...');
        alertsManager = new AlertsManager();
        window.alertsManager = alertsManager; // Make available for debugging
        console.log('‚úÖ AlertsManager initialized successfully');

        // Show debug info if enabled
        if (localStorage.getItem('alerts_debug') === 'true') {
            console.log('üêõ Alerts Debug Mode Enabled');
            console.log('Use getDebugInfo() to see current state');
            console.log('Use disableDebugMode() to turn off debug mode');
        } else {
            console.log('üí° Enable debug mode with: enableDebugMode()');
        }
    } catch (error) {
        console.error('‚ùå Failed to initialize AlertsManager:', error);

        // Show user-friendly error message
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            z-index: 9999;
            max-width: 90%;
            text-align: center;
        `;
        errorDiv.innerHTML = `
            <strong>Alerts Manager Error</strong><br>
            ${error.message || 'Unknown initialization error'}<br>
            <small>Check browser console for details</small>
        `;
        document.body.appendChild(errorDiv);

        // Auto-remove error after 10 seconds
        setTimeout(() => {
            if (errorDiv.parentNode) {
                errorDiv.remove();
            }
        }, 10000);
    }
});
</script>
{% endblock %}