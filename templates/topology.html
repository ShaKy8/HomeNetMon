{% extends "base_with_quickstats.html" %}

{% block title %}Network Topology - HomeNetMon{% endblock %}

{% block content %}
<div class="topology-page">
<div class="container-fluid">
<div class="d-flex justify-content-between align-items-center mb-4">
    <div>
        <h1 class="mb-1" style="font-weight: 700; color: var(--topology-text-primary);">Network Topology</h1>
        <p class="text-muted mb-0" style="font-size: 0.95rem;">Interactive network visualization and device management</p>
    </div>
    <div class="d-flex align-items-center gap-3">
        <button type="button" class="btn theme-toggle-btn" id="theme-toggle-btn" title="Toggle Dark/Light Theme">
            <i class="bi bi-moon-fill" id="theme-icon"></i>
        </button>
        <button type="button" class="btn btn-outline-secondary" id="fullscreen-btn" title="Toggle Fullscreen">
            <i class="bi bi-arrows-fullscreen"></i>
        </button>
    </div>
</div>

<!-- Interactive Network Graph -->
<div class="card mb-4" id="topology-card">
    <div class="card-header compact-header">
        <!-- Single Row: Title, Filters, and Actions -->
        <div class="d-flex align-items-center justify-content-between flex-wrap gap-3">
            <!-- Left: Title -->
            <h5 class="mb-0 d-flex align-items-center">
                <i class="bi bi-diagram-3 me-2"></i>Network Topology
            </h5>
            
            <!-- Center: Compact Filter Controls -->
            <div class="d-flex align-items-center gap-3 flex-wrap">
                <!-- Status Filters - Inline -->
                <div class="filter-inline">
                    <span class="filter-inline-label">Status:</span>
                    <div class="d-flex gap-2">
                        <div class="form-check form-check-inline mb-0">
                            <input class="form-check-input" type="checkbox" id="status-online" checked>
                            <label class="form-check-label compact" for="status-online">
                                <i class="bi bi-check-circle-fill text-success"></i>
                            </label>
                        </div>
                        <div class="form-check form-check-inline mb-0">
                            <input class="form-check-input" type="checkbox" id="status-offline" checked>
                            <label class="form-check-label compact" for="status-offline">
                                <i class="bi bi-x-circle-fill text-danger"></i>
                            </label>
                        </div>
                        <div class="form-check form-check-inline mb-0">
                            <input class="form-check-input" type="checkbox" id="status-warning" checked>
                            <label class="form-check-label compact" for="status-warning">
                                <i class="bi bi-exclamation-triangle-fill text-warning"></i>
                            </label>
                        </div>
                        <div class="form-check form-check-inline mb-0">
                            <input class="form-check-input" type="checkbox" id="status-unknown" checked>
                            <label class="form-check-label compact" for="status-unknown">
                                <i class="bi bi-question-circle-fill" style="color: var(--status-unknown);"></i>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Device Type Dropdown -->
                <div class="dropdown">
                    <button class="btn btn-outline-light btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown" title="Filter Device Types">
                        <i class="bi bi-funnel me-1"></i>Types
                    </button>
                    <div class="dropdown-menu p-3 device-type-dropdown">
                        <div class="row g-2">
                            <div class="col-6">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="type-router" checked>
                                    <label class="form-check-label small" for="type-router">
                                        <i class="bi bi-router me-1"></i>Router
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="type-computer" checked>
                                    <label class="form-check-label small" for="type-computer">
                                        <i class="bi bi-pc-display me-1"></i>Computer
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="type-apple" checked>
                                    <label class="form-check-label small" for="type-apple">
                                        <i class="bi bi-apple me-1"></i>Apple
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="type-phone" checked>
                                    <label class="form-check-label small" for="type-phone">
                                        <i class="bi bi-phone me-1"></i>Mobile
                                    </label>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="type-smart_home" checked>
                                    <label class="form-check-label small" for="type-smart_home">
                                        <i class="bi bi-house-gear me-1"></i>Smart
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="type-iot" checked>
                                    <label class="form-check-label small" for="type-iot">
                                        <i class="bi bi-cpu me-1"></i>IoT
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="type-camera" checked>
                                    <label class="form-check-label small" for="type-camera">
                                        <i class="bi bi-camera-video me-1"></i>Camera
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="type-unknown" checked>
                                    <label class="form-check-label small" for="type-unknown">
                                        <i class="bi bi-question-circle me-1"></i>Unknown
                                    </label>
                                </div>
                            </div>
                        </div>
                        <div class="border-top pt-2 mt-2">
                            <div class="d-flex gap-2">
                                <button type="button" class="btn btn-outline-primary btn-sm flex-fill" id="select-all-filters">
                                    <i class="bi bi-check-all me-1"></i>All
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm flex-fill" id="clear-all-filters">
                                    <i class="bi bi-x me-1"></i>None
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right: Actions -->
            <div class="d-flex align-items-center gap-2">
                <!-- Layout Controls -->
                <div class="btn-group btn-group-sm" role="group">
                    <button type="button" class="btn btn-outline-light" id="graph-layout-force" title="Force Layout">
                        <i class="bi bi-arrows-move"></i>
                    </button>
                    <button type="button" class="btn btn-outline-light" id="graph-layout-circle" title="Circle Layout">
                        <i class="bi bi-circle"></i>
                    </button>
                    <button type="button" class="btn btn-outline-light active" id="graph-layout-grid" title="Grid Layout">
                        <i class="bi bi-grid"></i>
                    </button>
                    <button type="button" class="btn btn-outline-light" id="graph-auto-arrange" title="Auto Arrange">
                        <i class="bi bi-magic"></i>
                    </button>
                </div>
                
                <!-- Zoom Controls -->
                <div class="btn-group btn-group-sm" role="group">
                    <button type="button" class="btn btn-outline-light" id="zoom-in" title="Zoom In">
                        <i class="bi bi-zoom-in"></i>
                    </button>
                    <button type="button" class="btn btn-outline-light" id="zoom-out" title="Zoom Out">
                        <i class="bi bi-zoom-out"></i>
                    </button>
                    <button type="button" class="btn btn-outline-light" id="zoom-fit" title="Fit to Screen">
                        <i class="bi bi-arrows-angle-contract"></i>
                    </button>
                </div>
                
                <!-- Action Buttons -->
                <button type="button" class="btn btn-outline-light btn-sm" id="graph-refresh" title="Refresh Data">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
                <button type="button" class="btn btn-outline-light btn-sm" id="graph-reset" title="Reset Positions">
                    <i class="bi bi-arrow-counterclockwise"></i>
                </button>
                
                <!-- Ping Dropdown -->
                <div class="btn-group btn-group-sm" role="group">
                    <button type="button" class="btn btn-outline-success" id="ping-visible-devices" title="Ping visible devices">
                        <i class="bi bi-broadcast"></i>
                    </button>
                    <button type="button" class="btn btn-outline-success dropdown-toggle dropdown-toggle-split" 
                            id="ping-more-options" data-bs-toggle="dropdown" aria-expanded="false">
                        <span class="visually-hidden">More ping options</span>
                    </button>
                    <ul class="dropdown-menu dropdown-menu-end">
                        <li><a class="dropdown-item" href="#" id="ping-all-devices">
                            <i class="bi bi-broadcast me-2"></i>All Devices
                        </a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item" href="#" id="ping-by-type-router">
                            <i class="bi bi-router me-2"></i>All Routers
                        </a></li>
                        <li><a class="dropdown-item" href="#" id="ping-by-type-camera">
                            <i class="bi bi-camera-video me-2"></i>All Cameras
                        </a></li>
                        <li><a class="dropdown-item" href="#" id="ping-by-type-apple">
                            <i class="bi bi-apple me-2"></i>All Apple Devices
                        </a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Filter Summary -->
    <div id="filter-summary-container" class="border-bottom bg-light px-3 py-2" style="display: none;">
        <div class="d-flex justify-content-between align-items-center">
            <div class="filter-summary-text">
                <small class="text-muted">
                    <i class="bi bi-funnel me-1"></i>
                    <span id="filter-summary-text">Showing all devices</span>
                </small>
            </div>
            <button type="button" class="btn btn-outline-secondary btn-sm" id="reset-filters" title="Reset all filters">
                <i class="bi bi-arrow-counterclockwise me-1"></i>Reset Filters
            </button>
        </div>
    </div>
    
    <!-- Ping Progress Modal -->
    <div id="ping-progress-modal" class="modal fade" tabindex="-1" aria-labelledby="pingProgressModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h6 class="modal-title" id="pingProgressModalLabel">
                        <i class="bi bi-broadcast me-2"></i>
                        <span id="ping-operation-title">Testing Network Connectivity</span>
                    </h6>
                    <button type="button" class="btn-close" id="ping-cancel-btn" aria-label="Cancel"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <span id="ping-progress-text" class="text-muted">0 / 0 devices</span>
                            <span id="ping-current-device" class="text-primary">Preparing...</span>
                        </div>
                        <div class="progress" style="height: 12px;">
                            <div id="ping-progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                            </div>
                        </div>
                    </div>
                    
                    <div class="row text-center">
                        <div class="col-4">
                            <div class="bg-success bg-opacity-10 rounded p-2">
                                <div class="text-success fs-4 fw-bold" id="ping-success-count">0</div>
                                <small class="text-success">
                                    <i class="bi bi-check-circle me-1"></i>Successful
                                </small>
                            </div>
                        </div>
                        <div class="col-4">
                            <div class="bg-danger bg-opacity-10 rounded p-2">
                                <div class="text-danger fs-4 fw-bold" id="ping-fail-count">0</div>
                                <small class="text-danger">
                                    <i class="bi bi-x-circle me-1"></i>Failed
                                </small>
                            </div>
                        </div>
                        <div class="col-4">
                            <div class="bg-info bg-opacity-10 rounded p-2">
                                <div class="text-info fs-4 fw-bold" id="ping-remaining-count">0</div>
                                <small class="text-info">
                                    <i class="bi bi-clock me-1"></i>Remaining
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="ping-cancel-secondary-btn">Cancel Operation</button>
                    <button type="button" class="btn btn-primary" id="ping-close-btn" style="display: none;">Close</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="card-body p-0">
        <div id="network-graph" style="height: 600px; width: 100%; position: relative; overflow: hidden;">
            <div class="d-flex justify-content-center align-items-center h-100">
                <div class="text-center">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading network graph...</span>
                    </div>
                    <p class="mt-2 text-muted">Loading network topology...</p>
                </div>
            </div>
            <!-- Enhanced Device Tooltip with Better Information Hierarchy -->
            <div id="device-tooltip" class="position-absolute" style="display: none; z-index: 1000; pointer-events: none;">
                <div class="card shadow-lg border-0" style="min-width: 320px; max-width: 380px;">
                    <!-- Tooltip Header with Device Identity -->
                    <div class="card-header border-0 bg-transparent p-0">
                        <div class="d-flex align-items-center p-3 pb-2">
                            <div class="device-icon-container me-3 p-2 rounded-circle d-flex align-items-center justify-content-center" 
                                 style="background: rgba(var(--topology-primary-rgb), 0.1); width: 40px; height: 40px;">
                                <span id="tooltip-icon" style="font-size: 1.2em; color: var(--topology-primary);">❓</span>
                            </div>
                            <div class="flex-grow-1">
                                <h6 id="tooltip-name" class="mb-1 fw-bold" style="color: var(--topology-text-primary);">Device Name</h6>
                                <div class="d-flex align-items-center">
                                    <small id="tooltip-ip" class="text-muted me-2">IP Address</small>
                                    <span id="tooltip-status" class="badge rounded-pill bg-secondary">Status</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Primary Metrics Grid -->
                    <div class="card-body pt-0">
                        <div class="row g-3 mb-3">
                            <div class="col-6">
                                <div class="metric-card p-2 rounded" style="background: var(--topology-bg-tertiary);">
                                    <div class="d-flex align-items-center">
                                        <i class="bi bi-speedometer2 text-primary me-2" style="font-size: 1.1em;"></i>
                                        <div>
                                            <small class="text-muted d-block mb-1" style="font-size: 0.75rem; font-weight: 500;">Response Time</small>
                                            <div id="tooltip-response" class="fw-bold" style="color: var(--topology-text-primary);">N/A</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="metric-card p-2 rounded" style="background: var(--topology-bg-tertiary);">
                                    <div class="d-flex align-items-center">
                                        <i class="bi bi-graph-up-arrow text-success me-2" style="font-size: 1.1em;"></i>
                                        <div>
                                            <small class="text-muted d-block mb-1" style="font-size: 0.75rem; font-weight: 500;">Uptime</small>
                                            <div id="tooltip-uptime" class="fw-bold" style="color: var(--topology-text-primary);">N/A</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Secondary Information -->
                        <div class="row g-3 mb-3">
                            <div class="col-6">
                                <div class="d-flex align-items-center">
                                    <i class="bi bi-diagram-3 text-info me-2" style="font-size: 1em;"></i>
                                    <div>
                                        <small class="text-muted d-block" style="font-size: 0.75rem;">Device Type</small>
                                        <span id="tooltip-type" class="fw-medium" style="font-size: 0.875rem; color: var(--topology-text-primary);">Unknown</span>
                                    </div>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="d-flex align-items-center">
                                    <i class="bi bi-exclamation-triangle text-warning me-2" style="font-size: 1em;"></i>
                                    <div>
                                        <small class="text-muted d-block" style="font-size: 0.75rem;">Active Alerts</small>
                                        <span id="tooltip-alerts" class="fw-medium" style="font-size: 0.875rem; color: var(--topology-text-primary);">0</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Footer Information -->
                        <div class="border-top pt-3" style="border-color: var(--topology-border-light) !important;">
                            <div class="d-flex align-items-center justify-content-between">
                                <small class="text-muted d-flex align-items-center" style="font-size: 0.8125rem;">
                                    <i class="bi bi-clock me-1"></i>
                                    Last seen: <span id="tooltip-last-seen" class="ms-1 fw-medium">Unknown</span>
                                </small>
                            </div>
                            <div class="mt-2 text-center">
                                <small class="d-flex align-items-center justify-content-center" style="color: var(--topology-primary); font-weight: 500; font-size: 0.8125rem;">
                                    <i class="bi bi-cursor-fill me-1"></i>
                                    Click for detailed device information
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Graph Legend - Compact -->
        <div class="border-top px-3 py-2 bg-light">
            <div class="d-flex align-items-center justify-content-between flex-wrap gap-2">
                <!-- Status Legend -->
                <div class="d-flex align-items-center gap-3">
                    <small class="text-muted fw-bold me-2">Status:</small>
                    <div class="d-flex align-items-center gap-1">
                        <span class="badge" style="background-color: #28a745; width: 10px; height: 10px; border-radius: 50%; display: inline-block;"></span>
                        <small class="ms-1">Online</small>
                    </div>
                    <div class="d-flex align-items-center gap-1">
                        <span class="badge" style="background-color: #dc3545; width: 10px; height: 10px; border-radius: 50%; display: inline-block;"></span>
                        <small class="ms-1">Offline</small>
                    </div>
                    <div class="d-flex align-items-center gap-1">
                        <span class="badge" style="background-color: #ffc107; width: 10px; height: 10px; border-radius: 50%; display: inline-block;"></span>
                        <small class="ms-1">Warning</small>
                    </div>
                </div>
                <!-- Device Types -->
                <div class="d-flex align-items-center gap-2">
                    <small class="text-muted fw-bold me-1">Types:</small>
                    <i class="bi bi-router" title="Router"></i>
                    <i class="bi bi-pc-display" title="Computer"></i>
                    <i class="bi bi-phone" title="Mobile"></i>
                    <i class="bi bi-house-gear" title="Smart Home"></i>
                    <i class="bi bi-cpu" title="IoT"></i>
                    <i class="bi bi-camera-video" title="Camera"></i>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Network Overview Cards -->
<div class="row mb-3">
    <div class="col-md-3">
        <div class="card stats-card">
            <div class="card-body text-center py-2">
                <div class="d-flex align-items-center justify-content-center">
                    <i class="bi bi-router fs-3 me-2"></i>
                    <div>
                        <h5 class="mb-0" id="overview-total">-</h5>
                        <small class="text-muted">Total Devices</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-3">
        <div class="card border-success">
            <div class="card-body text-center py-2">
                <div class="d-flex align-items-center justify-content-center">
                    <i class="bi bi-check-circle fs-3 text-success me-2"></i>
                    <div>
                        <h5 class="mb-0 text-success" id="overview-up">-</h5>
                        <small class="text-muted">Online</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-3">
        <div class="card border-danger">
            <div class="card-body text-center py-2">
                <div class="d-flex align-items-center justify-content-center">
                    <i class="bi bi-x-circle fs-3 text-danger me-2"></i>
                    <div>
                        <h5 class="mb-0 text-danger" id="overview-down">-</h5>
                        <small class="text-muted">Offline</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-3">
        <div class="card border-warning">
            <div class="card-body text-center py-2">
                <div class="d-flex align-items-center justify-content-center">
                    <i class="bi bi-exclamation-triangle fs-3 text-warning me-2"></i>
                    <div>
                        <h5 class="mb-0 text-warning" id="overview-alerts">-</h5>
                        <small class="text-muted">Alerts</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</div>
</div>

<style>
/* ========================================
   Modern Network Topology Styling - 2025
   ======================================== */

/* CSS Custom Properties for Theming */
:root {
    /* Modern Color Palette */
    --topology-primary: #6366f1;
    --topology-primary-rgb: 99, 102, 241;
    --topology-secondary: #8b5cf6;
    --topology-accent: #06b6d4;
    --topology-success: #10b981;
    --topology-warning: #f59e0b;
    --topology-danger: #ef4444;
    --topology-info: #3b82f6;
    
    /* Status Colors - Enhanced */
    --status-online: #10b981;
    --status-online-rgb: 16, 185, 129;
    --status-offline: #ef4444;
    --status-offline-rgb: 239, 68, 68;
    --status-warning: #f59e0b;
    --status-warning-rgb: 245, 158, 11;
    --status-unknown: #6b7280;
    --status-unknown-rgb: 107, 114, 128;
    
    /* Background Colors */
    --topology-bg-primary: #ffffff;
    --topology-bg-secondary: #f8fafc;
    --topology-bg-tertiary: #f1f5f9;
    --topology-surface: #ffffff;
    --topology-surface-elevated: #ffffff;
    
    /* Text Colors */
    --topology-text-primary: #1e293b;
    --topology-text-secondary: #64748b;
    --topology-text-muted: #94a3b8;
    --topology-text-inverse: #ffffff;
    
    /* Border Colors */
    --topology-border-light: #e2e8f0;
    --topology-border-medium: #cbd5e1;
    --topology-border-strong: #94a3b8;
    
    /* Shadows & Effects */
    --topology-shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --topology-shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --topology-shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
    --topology-shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
    
    /* Glassmorphism */
    --glass-bg: rgba(255, 255, 255, 0.25);
    --glass-border: rgba(255, 255, 255, 0.18);
    --glass-backdrop: blur(16px);
    
    /* Spacing Scale */
    --space-1: 0.25rem;
    --space-2: 0.5rem;
    --space-3: 0.75rem;
    --space-4: 1rem;
    --space-5: 1.25rem;
    --space-6: 1.5rem;
    --space-8: 2rem;
    --space-10: 2.5rem;
    --space-12: 3rem;
    
    /* Border Radius */
    --radius-sm: 0.375rem;
    --radius-md: 0.5rem;
    --radius-lg: 0.75rem;
    --radius-xl: 1rem;
    --radius-2xl: 1.5rem;
    
    /* Transitions */
    --transition-fast: 150ms ease-in-out;
    --transition-base: 250ms ease-in-out;
    --transition-slow: 350ms ease-in-out;
}

/* Dark Theme */
[data-theme="dark"] {
    /* Dark Background Colors */
    --topology-bg-primary: #0f172a;
    --topology-bg-secondary: #1e293b;
    --topology-bg-tertiary: #334155;
    --topology-surface: #1e293b;
    --topology-surface-elevated: #334155;
    
    /* Dark Text Colors */
    --topology-text-primary: #f8fafc;
    --topology-text-secondary: #cbd5e1;
    --topology-text-muted: #94a3b8;
    
    /* Dark Border Colors */
    --topology-border-light: #334155;
    --topology-border-medium: #475569;
    --topology-border-strong: #64748b;
    
    /* Dark Glassmorphism */
    --glass-bg: rgba(30, 41, 59, 0.25);
    --glass-border: rgba(203, 213, 225, 0.18);
}

/* Base Styles with Modern Design */
.topology-page {
    background: linear-gradient(135deg, var(--topology-bg-primary) 0%, var(--topology-bg-secondary) 100%);
    color: var(--topology-text-primary);
    min-height: 100vh;
    transition: all var(--transition-base);
}

/* Fullscreen styles */
.fullscreen-mode {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
    background: var(--topology-bg-primary) !important;
    margin: 0 !important;
}

.fullscreen-mode .card-body {
    padding: 0 !important;
}

.fullscreen-mode #network-graph {
    height: calc(100vh - 120px) !important;
}

.fullscreen-exit-btn {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 10000;
    background: var(--glass-bg) !important;
    backdrop-filter: var(--glass-backdrop);
    border: 1px solid var(--glass-border);
    box-shadow: var(--topology-shadow-lg);
}

/* ========================================
   Enhanced Card Styling with Glassmorphism
   ======================================== */

.card {
    background: var(--topology-surface);
    border: 1px solid var(--topology-border-light);
    border-radius: var(--radius-xl);
    box-shadow: var(--topology-shadow-md);
    transition: all var(--transition-base);
}

.card:hover {
    transform: translateY(-2px);
    box-shadow: var(--topology-shadow-lg);
}

.card-header {
    background: linear-gradient(135deg, var(--topology-primary) 0%, var(--topology-secondary) 100%) !important;
    border-bottom: none;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0 !important;
    padding: var(--space-4) var(--space-5);
    backdrop-filter: var(--glass-backdrop);
}

/* Compact Header Styling */
.compact-header {
    padding: var(--space-3) var(--space-4) !important;
}

.compact-header h5 {
    font-size: 1.1rem;
    font-weight: 600;
}

/* Compact Filter Styling */
.filter-inline {
    display: flex;
    align-items: center;
    gap: var(--space-2);
}

.filter-inline-label {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--topology-text-inverse);
    opacity: 0.9;
    white-space: nowrap;
}

.form-check-label.compact {
    padding: 0;
    margin: 0;
    cursor: pointer;
}

.form-check-label.compact i {
    font-size: 1.1em;
}

/* Device Type Dropdown */
.device-type-dropdown {
    min-width: 280px;
    max-width: 320px;
}

.device-type-dropdown .form-check {
    margin-bottom: 0.25rem;
}

.device-type-dropdown .form-check-label {
    font-size: 0.875rem;
    font-weight: 500;
}

.card-header h5 {
    color: var(--topology-text-inverse) !important;
    font-weight: 600;
    letter-spacing: 0.025em;
    margin: 0;
}

/* Enhanced Network Graph Container */
#network-graph {
    background: linear-gradient(135deg, var(--topology-bg-secondary) 0%, var(--topology-bg-tertiary) 100%);
    border-radius: var(--radius-lg);
    position: relative;
    overflow: hidden;
}

/* Modern Filter Groups */
.filter-group {
    background: var(--glass-bg);
    border: 1px solid var(--topology-border-light);
    border-radius: var(--radius-lg);
    padding: var(--space-4) var(--space-5);
    backdrop-filter: var(--glass-backdrop);
    transition: all var(--transition-base);
}

.filter-group:hover {
    background: var(--topology-surface-elevated);
    box-shadow: var(--topology-shadow-sm);
}

.filter-group-label {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--topology-text-secondary);
    margin-bottom: var(--space-3) !important;
}

/* Enhanced Checkboxes with Modern Toggle Style */
.form-check-input {
    background-color: var(--topology-surface);
    border: 2px solid var(--topology-border-medium);
    border-radius: var(--radius-sm);
    transition: all var(--transition-fast);
    cursor: pointer;
}

.form-check-input:checked {
    background-color: var(--topology-primary);
    border-color: var(--topology-primary);
    box-shadow: 0 0 0 3px rgba(var(--topology-primary-rgb), 0.1);
}

.form-check-input:focus {
    box-shadow: 0 0 0 3px rgba(var(--topology-primary-rgb), 0.2);
}

.form-check-label {
    font-weight: 500;
    color: var(--topology-text-primary);
    cursor: pointer;
    transition: color var(--transition-fast);
}

.form-check-label:hover {
    color: var(--topology-primary);
}

/* Modern Button Styling */
.btn {
    border-radius: var(--radius-md);
    font-weight: 500;
    letter-spacing: 0.025em;
    transition: all var(--transition-fast);
    border: none;
    position: relative;
    overflow: hidden;
}

.btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left var(--transition-base);
}

.btn:hover::before {
    left: 100%;
}

.btn-outline-secondary {
    background: var(--glass-bg);
    color: var(--topology-text-primary);
    border: 1px solid var(--topology-border-medium);
    backdrop-filter: var(--glass-backdrop);
}

.btn-outline-secondary:hover {
    background: var(--topology-surface-elevated);
    color: var(--topology-primary);
    border-color: var(--topology-primary);
    transform: translateY(-1px);
    box-shadow: var(--topology-shadow-md);
}

.btn-outline-light {
    background: var(--glass-bg);
    color: var(--topology-text-inverse);
    border: 1px solid var(--glass-border);
    backdrop-filter: var(--glass-backdrop);
}

.btn-outline-light:hover,
.btn-outline-light.active {
    background: rgba(255, 255, 255, 0.2);
    color: var(--topology-text-inverse);
    border-color: rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
}

.btn-success {
    background: linear-gradient(135deg, var(--topology-success) 0%, #059669 100%);
    color: white;
    box-shadow: var(--topology-shadow-sm);
}

.btn-success:hover {
    background: linear-gradient(135deg, #059669 0%, #047857 100%);
    transform: translateY(-1px);
    box-shadow: var(--topology-shadow-md);
}

/* ========================================
   Enhanced Tooltip Styling
   ======================================== */
   
#device-tooltip {
    transition: all var(--transition-base);
    filter: drop-shadow(var(--topology-shadow-xl));
}

#device-tooltip .card {
    background: var(--glass-bg);
    backdrop-filter: var(--glass-backdrop);
    border: 1px solid var(--glass-border);
    border-radius: var(--radius-xl);
    box-shadow: var(--topology-shadow-xl);
    overflow: hidden;
    max-width: 350px;
}

#device-tooltip .card-body {
    padding: var(--space-5);
    background: linear-gradient(135deg, var(--topology-surface) 0%, var(--topology-surface-elevated) 100%);
}

#device-tooltip h6 {
    font-weight: 600;
    color: var(--topology-text-primary);
    margin-bottom: var(--space-2);
}

#device-tooltip .text-muted {
    color: var(--topology-text-secondary) !important;
    font-size: 0.875rem;
}

#device-tooltip .badge {
    font-weight: 600;
    padding: var(--space-2) var(--space-3);
    border-radius: var(--radius-md);
}

#device-tooltip .border-top {
    border-color: var(--topology-border-light) !important;
    margin-top: var(--space-4);
    padding-top: var(--space-4);
}

#device-tooltip .row .col-6 {
    padding: var(--space-2);
}

#device-tooltip .row .col-6:hover {
    background: var(--topology-bg-tertiary);
    border-radius: var(--radius-sm);
    transition: background var(--transition-fast);
}

/* Theme Toggle Button */
.theme-toggle-btn {
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    border-radius: var(--radius-lg);
    padding: var(--space-3);
    backdrop-filter: var(--glass-backdrop);
    transition: all var(--transition-fast);
    cursor: pointer;
    color: var(--topology-text-primary);
}

.theme-toggle-btn:hover {
    background: var(--topology-surface-elevated);
    transform: translateY(-1px);
    box-shadow: var(--topology-shadow-md);
}

/* Overview Stats Cards */
.stats-card {
    background: linear-gradient(135deg, var(--topology-surface) 0%, var(--topology-surface-elevated) 100%);
    border: 1px solid var(--topology-border-light);
    border-radius: var(--radius-xl);
    transition: all var(--transition-base);
    overflow: hidden;
    position: relative;
}

.stats-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, var(--topology-primary), var(--topology-secondary));
}

.stats-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--topology-shadow-lg);
}

.stats-card .card-body {
    padding: var(--space-5);
}

.stats-card h5 {
    font-weight: 700;
    font-size: 1.75rem;
}

.stats-card small {
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--topology-text-secondary);
}

/* Border color overrides for stats cards */
.border-success {
    border-color: var(--topology-success) !important;
}

.border-success::before {
    background: linear-gradient(90deg, var(--topology-success), #059669);
}

.border-danger {
    border-color: var(--topology-danger) !important;
}

.border-danger::before {
    background: linear-gradient(90deg, var(--topology-danger), #dc2626);
}

.border-warning {
    border-color: var(--topology-warning) !important;
}

.border-warning::before {
    background: linear-gradient(90deg, var(--topology-warning), #d97706);
}

/* Status Icons with Enhanced Colors */
.text-success {
    color: var(--topology-success) !important;
}

.text-danger {
    color: var(--topology-danger) !important;
}

.text-warning {
    color: var(--topology-warning) !important;
}

/* ========================================
   Enhanced Typography System
   ======================================== */

/* Improved font weights and sizes */
h1, h2, h3, h4, h5, h6 {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    font-weight: 600;
    line-height: 1.2;
    color: var(--topology-text-primary);
    letter-spacing: -0.025em;
}

h1 {
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: var(--space-2);
}

h5 {
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: var(--space-3);
}

/* Body text improvements */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.95rem;
    line-height: 1.6;
    color: var(--topology-text-primary);
}

p {
    margin-bottom: var(--space-4);
    color: var(--topology-text-secondary);
}

.text-muted {
    color: var(--topology-text-muted) !important;
    font-weight: 400;
}

/* Enhanced button typography */
.btn {
    font-family: inherit;
    font-weight: 500;
    font-size: 0.875rem;
    line-height: 1.5;
    letter-spacing: 0.025em;
}

.btn-sm {
    font-size: 0.8125rem;
    font-weight: 500;
}

/* Form labels and inputs */
.form-check-label {
    font-size: 0.875rem;
    font-weight: 500;
    line-height: 1.4;
    color: var(--topology-text-primary);
}

.form-check-label small {
    font-size: 0.8125rem;
    font-weight: 400;
}

/* Legend and help text */
.legend-text {
    font-size: 0.8125rem;
    font-weight: 500;
    line-height: 1.4;
    color: var(--topology-text-secondary);
}

/* Enhanced spacing for better visual hierarchy */
.mb-2 {
    margin-bottom: var(--space-2) !important;
}

.mb-3 {
    margin-bottom: var(--space-3) !important;
}

.mb-4 {
    margin-bottom: var(--space-4) !important;
}

.mt-2 {
    margin-top: var(--space-2) !important;
}

.mt-3 {
    margin-top: var(--space-3) !important;
}

.py-2 {
    padding-top: var(--space-2) !important;
    padding-bottom: var(--space-2) !important;
}

.py-3 {
    padding-top: var(--space-3) !important;
    padding-bottom: var(--space-3) !important;
}

.px-3 {
    padding-left: var(--space-3) !important;
    padding-right: var(--space-3) !important;
}

.px-4 {
    padding-left: var(--space-4) !important;
    padding-right: var(--space-4) !important;
}

.p-3 {
    padding: var(--space-3) !important;
}

.p-4 {
    padding: var(--space-4) !important;
}

/* Gap utilities using CSS custom properties */
.gap-2 {
    gap: var(--space-2) !important;
}

.gap-3 {
    gap: var(--space-3) !important;
}

/* Filter summary and status text improvements */
#filter-summary-text {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--topology-text-secondary);
}

/* Network range and overview stats text */
.overview-stats small {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--topology-text-muted);
}

/* Enhanced card content typography */
.card-body h5,
.card-body h6 {
    color: var(--topology-text-primary);
    margin-bottom: var(--space-3);
}

.card-body p,
.card-body .text-muted {
    font-size: 0.875rem;
    line-height: 1.5;
    margin-bottom: var(--space-3);
}

/* ========================================
   Enhanced Node and Connection Styling
   ======================================== */

/* Node Interactive States */
.node {
    cursor: pointer;
    transition: all var(--transition-base);
}

.node:hover circle {
    filter: brightness(1.2) drop-shadow(0 0 8px rgba(var(--topology-primary-rgb), 0.4));
    transform: scale(1.05);
    stroke: var(--topology-primary) !important;
    stroke-width: 4 !important;
}

.node:hover .device-icon {
    transform: scale(1.1);
}

.node:hover text {
    font-weight: 600;
    fill: var(--topology-primary);
}

/* Node Animation on Creation */
.node circle {
    animation: nodeEnter 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
}

@keyframes nodeEnter {
    0% {
        r: 0;
        opacity: 0;
        transform: scale(0);
    }
    60% {
        r: calc(var(--node-radius, 20px) * 1.2);
        opacity: 0.8;
    }
    100% {
        r: var(--node-radius, 20px);
        opacity: 1;
        transform: scale(1);
    }
}

/* Connection Lines Enhancement */
.link {
    transition: all var(--transition-fast);
    cursor: pointer;
}

.link:hover {
    stroke-width: 4 !important;
    stroke: var(--topology-primary) !important;
    stroke-opacity: 0.8 !important;
    filter: drop-shadow(0 0 4px rgba(var(--topology-primary-rgb), 0.3));
}

/* Connection Animation */
@keyframes linkPulse {
    0%, 100% {
        stroke-opacity: 0.6;
        stroke-width: 2;
    }
    50% {
        stroke-opacity: 1;
        stroke-width: 3;
    }
}

.link-active {
    animation: linkPulse 2s infinite ease-in-out;
}

/* Enhanced Status Indicators */
.node-status-online circle {
    fill: var(--status-online);
    box-shadow: 0 0 12px rgba(var(--status-online-rgb), 0.3);
    animation: statusPulse 3s infinite ease-in-out;
}

.node-status-offline circle {
    fill: var(--status-offline);
    stroke-dasharray: 8, 4;
    animation: statusOffline 2s infinite linear;
}

@keyframes statusPulse {
    0%, 100% {
        filter: brightness(1) drop-shadow(0 0 4px rgba(var(--status-online-rgb), 0.2));
    }
    50% {
        filter: brightness(1.1) drop-shadow(0 0 8px rgba(var(--status-online-rgb), 0.4));
    }
}

@keyframes statusOffline {
    0% {
        stroke-dashoffset: 0;
    }
    100% {
        stroke-dashoffset: -12;
    }
}

.node-status-warning circle {
    fill: var(--status-warning);
    animation: statusWarning 1.5s infinite ease-in-out;
}

@keyframes statusWarning {
    0%, 100% {
        filter: brightness(1);
    }
    50% {
        filter: brightness(1.2) drop-shadow(0 0 6px rgba(var(--status-warning-rgb), 0.5));
    }
}

/* Ping state animations */
.node-pinging circle {
    animation: ping-pulse 1s infinite;
}

@keyframes ping-pulse {
    0% { stroke-opacity: 1; }
    50% { stroke-opacity: 0.4; }
    100% { stroke-opacity: 1; }
}

.node-ping-success circle {
    stroke: #28a745 !important;
    stroke-width: 3 !important;
}

.node-ping-failed circle {
    stroke: #dc3545 !important;
    stroke-width: 3 !important;
}

/* Progress container animations */
#ping-progress-container {
    transition: all 0.3s ease-in-out;
}

/* ========================================
   Enhanced Modal Styling
   ======================================== */

.modal .modal-dialog {
    transition: all var(--transition-base);
}

.modal .modal-content {
    border: none;
    border-radius: var(--radius-xl);
    background: var(--topology-surface);
    box-shadow: var(--topology-shadow-xl);
    backdrop-filter: var(--glass-backdrop);
}

.modal .modal-header {
    background: linear-gradient(135deg, var(--topology-primary) 0%, var(--topology-secondary) 100%);
    color: var(--topology-text-inverse);
    border-bottom: none;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
    padding: var(--space-5) var(--space-6);
}

.modal .modal-header .modal-title {
    font-weight: 600;
    font-size: 1.125rem;
}

.modal .modal-header .btn-close {
    background: rgba(255, 255, 255, 0.2);
    border-radius: var(--radius-md);
    opacity: 1;
    padding: var(--space-2);
    transition: all var(--transition-fast);
}

.modal .modal-header .btn-close:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

.modal .modal-body {
    padding: var(--space-6);
    color: var(--topology-text-primary);
}

.modal .modal-footer {
    border-top: 1px solid var(--topology-border-light);
    background: var(--topology-bg-secondary);
    padding: var(--space-5) var(--space-6);
    border-radius: 0 0 var(--radius-xl) var(--radius-xl);
}

/* Enhanced Progress Bars */
.progress {
    background-color: var(--topology-bg-tertiary);
    border-radius: var(--radius-lg);
    height: 12px;
    overflow: hidden;
    box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
}

.progress-bar {
    background: linear-gradient(90deg, var(--topology-primary), var(--topology-secondary));
    transition: width var(--transition-base);
    border-radius: var(--radius-lg);
}

.progress-bar-animated {
    animation: progress-bar-stripes 1s linear infinite;
}

@keyframes progress-bar-stripes {
    0% {
        background-position: 0 0;
    }
    100% {
        background-position: 40px 0;
    }
}

/* Ping Progress Modal Specific Styling */
#ping-progress-modal .modal-dialog {
    max-width: 520px;
}

#ping-progress-modal .row > div {
    transition: all var(--transition-fast);
}

#ping-progress-modal .row > div:hover {
    transform: translateY(-2px);
}

#ping-progress-modal .bg-success {
    background: linear-gradient(135deg, var(--topology-success), #059669) !important;
    border-radius: var(--radius-lg);
}

#ping-progress-modal .bg-danger {
    background: linear-gradient(135deg, var(--topology-danger), #dc2626) !important;
    border-radius: var(--radius-lg);
}

#ping-progress-modal .bg-info {
    background: linear-gradient(135deg, var(--topology-info), #2563eb) !important;
    border-radius: var(--radius-lg);
}

#ping-progress-modal .fs-4 {
    font-weight: 700;
    font-size: 1.75rem;
}

/* Toast notifications */
.toast {
    background: var(--glass-bg);
    backdrop-filter: var(--glass-backdrop);
    border: 1px solid var(--glass-border);
    border-radius: var(--radius-lg);
    box-shadow: var(--topology-shadow-lg);
    transition: all var(--transition-base);
}

.toast-body {
    color: var(--topology-text-inverse);
    font-weight: 500;
}

/* Filter group styling */
.filter-group {
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    padding: 0.75rem;
    background-color: rgba(255, 255, 255, 0.05);
}

.filter-group-label {
    font-size: 0.75rem;
    letter-spacing: 0.05em;
    margin-bottom: 0.5rem !important;
}

.form-check-inline {
    margin-right: 1rem;
}

.form-check-label.small {
    font-size: 0.875rem;
    cursor: pointer;
}

/* Filter summary styling */
#filter-summary-container {
    transition: all 0.3s ease-in-out;
}

/* ========================================
   Enhanced Control Section Layout
   ======================================== */

.control-section {
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
}

.control-section-label {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--topology-text-inverse);
    opacity: 0.8;
    margin-bottom: var(--space-2);
}

/* Enhanced dropdown styling */
.dropdown-menu {
    background: var(--topology-surface);
    border: 1px solid var(--topology-border-light);
    border-radius: var(--radius-lg);
    box-shadow: var(--topology-shadow-lg);
    backdrop-filter: var(--glass-backdrop);
    padding: var(--space-2);
}

.dropdown-item {
    border-radius: var(--radius-md);
    padding: var(--space-2) var(--space-3);
    color: var(--topology-text-primary);
    font-weight: 500;
    transition: all var(--transition-fast);
}

.dropdown-item:hover {
    background: var(--topology-bg-tertiary);
    color: var(--topology-primary);
    transform: translateX(2px);
}

.dropdown-item i {
    width: 1.2em;
    text-align: center;
}

.dropdown-divider {
    border-color: var(--topology-border-light);
    margin: var(--space-2) 0;
}

/* Ping controls styling */
.ping-controls .btn-success {
    font-weight: 500;
}

/* ========================================
   Enhanced Layout Button Styling
   ======================================== */

.btn-group .btn {
    transition: all var(--transition-fast);
    position: relative;
    overflow: hidden;
}

.btn-group .btn:before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left var(--transition-base);
}

.btn-group .btn:hover:before {
    left: 100%;
}

.btn-group .btn.active {
    background: rgba(255, 255, 255, 0.3) !important;
    border-color: rgba(255, 255, 255, 0.5) !important;
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
    transform: scale(1.05);
}

.btn-group .btn:disabled {
    opacity: 0.6 !important;
    cursor: not-allowed !important;
    transform: none !important;
}

/* Layout feedback animations */
.layout-feedback {
    pointer-events: none;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

/* Enhanced tooltip positioning */
.btn[title]:hover::after {
    content: attr(title);
    position: absolute;
    bottom: -35px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1000;
    pointer-events: none;
}
</style>
{% endblock %}

{% block scripts %}
<script>
let networkGraph;
let isFullscreen = false;
let currentTheme = 'light';

// Theme management
function initializeTheme() {
    // Check for saved theme or default to light
    const savedTheme = localStorage.getItem('topology-theme') || 'light';
    setTheme(savedTheme);
}

function setTheme(theme) {
    currentTheme = theme;
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('topology-theme', theme);
    
    // Update theme toggle icon
    const themeIcon = document.getElementById('theme-icon');
    if (themeIcon) {
        themeIcon.className = theme === 'dark' ? 'bi bi-sun-fill' : 'bi bi-moon-fill';
    }
    
    // Update graph background if it exists
    if (networkGraph && networkGraph.svg) {
        const bgColor = getComputedStyle(document.documentElement)
            .getPropertyValue('--topology-bg-secondary').trim();
        networkGraph.svg.style('background', `linear-gradient(135deg, ${bgColor} 0%, var(--topology-bg-tertiary) 100%)`);
    }
}

function toggleTheme() {
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    setTheme(newTheme);
}

// Network Graph Visualization
class NetworkGraph {
    constructor(containerId) {
        this.containerId = containerId;
        this.container = d3.select(`#${containerId}`);
        this.width = 0;
        this.height = 600;
        this.svg = null;
        this.simulation = null;
        this.nodes = [];
        this.links = [];
        this.currentLayout = 'grid';
        this.nodeGroup = null;
        this.linkGroup = null;
        
        // Filter state management with checkbox approach
        this.activeFilters = {
            // Status filters (map to checkbox IDs)
            up: true,      // status-online
            down: true,    // status-offline
            warning: true, // status-warning
            unknown: true, // status-unknown
            
            // Device type filters (map to checkbox IDs)
            router: true,     // type-router
            computer: true,   // type-computer
            apple: true,      // type-apple
            phone: true,      // type-phone
            smart_home: true, // type-smart_home
            iot: true,        // type-iot
            camera: true,     // type-camera
            'unknown-type': true  // type-unknown (renamed to avoid conflict)
        };
        this.allNodesData = []; // Store original unfiltered data
        this.allLinksData = []; // Store original unfiltered links
        
        // Ping operation management
        this.pingModal = null;
        this.isPingOperationRunning = false;
        
        this.init();
        this.loadData();
        this.startAutoRefresh();
    }
    
    init() {
        const container = this.container.node();
        this.width = container.clientWidth;
        this.height = container.clientHeight;
        
        // Clear existing content
        this.container.selectAll('*').remove();
        
        // Create SVG with CSS custom property background
        this.svg = this.container.append('svg')
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('viewBox', `0 0 ${this.width} ${this.height}`)
            .style('background', 'linear-gradient(135deg, var(--topology-bg-secondary) 0%, var(--topology-bg-tertiary) 100%)')
            .style('cursor', 'grab');
        
        // Create zoom behavior
        this.zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                this.zoomGroup.attr('transform', event.transform);
                this.currentTransform = event.transform;
            });
        
        // Apply zoom behavior to SVG
        this.svg.call(this.zoom);
        
        // Create main zoom group
        this.zoomGroup = this.svg.append('g').attr('class', 'zoom-group');
            
        // Create groups for links and nodes within zoom group
        this.linkGroup = this.zoomGroup.append('g').attr('class', 'links');
        this.nodeGroup = this.zoomGroup.append('g').attr('class', 'nodes');
        
        // Initialize zoom transform
        this.currentTransform = d3.zoomIdentity;
        
        // Add boundary constraints
        this.margin = 50;
        
        // Create simulation with improved node separation
        this.simulation = d3.forceSimulation()
            .force('link', d3.forceLink().id(d => d.id).strength(0.2))
            .force('charge', d3.forceManyBody().strength(-300))  // Increased repulsion
            .force('center', d3.forceCenter(this.width / 2, this.height / 2))
            .force('collision', d3.forceCollide().radius(40).strength(0.9))  // Larger collision radius with stronger enforcement
            .velocityDecay(0.4);  // Slower cooling for better settling
    }
    
    async loadData() {
        try {
            const response = await fetch('/api/monitoring/topology-test');
            const data = await response.json();
            
            if (data.nodes && data.edges) {
                this.updateGraph(data.nodes, data.edges);
                // Update stats will be handled by updateFilteredStats after applyFilters
            }
        } catch (error) {
            console.error('Error loading topology data:', error);
        }
    }
    
    updateGraph(nodes, edges) {
        // Store original data for filtering
        this.allNodesData = nodes.map(d => ({...d}));
        this.allLinksData = edges.map(d => ({...d}));
        
        // Apply current filters
        this.applyFilters();
    }
    
    // Filter Management Methods
    setFilter(status, enabled) {
        console.log(`TopologyFilter: Setting ${status} filter to ${enabled}`);
        
        if (status === 'all') {
            // Handle "All" button - enable/disable all filters
            this.activeFilters.all = enabled;
            this.activeFilters.up = enabled;
            this.activeFilters.down = enabled;
            this.activeFilters.warning = enabled;
            this.activeFilters.unknown = enabled;
        } else {
            // Handle individual status filters
            this.activeFilters[status] = enabled;
            
            // Update "All" filter state based on individual filters
            this.activeFilters.all = this.activeFilters.up && 
                                   this.activeFilters.down && 
                                   this.activeFilters.warning && 
                                   this.activeFilters.unknown;
        }
        
        this.applyFilters();
        this.updateFilterUI();
    }
    
    applyFilters() {
        console.log('TopologyFilter: Applying filters', this.activeFilters);
        
        // Filter nodes based on active filters (both status and device type)
        this.nodes = this.allNodesData.filter(node => {
            // Check status filter
            const statusFilterKey = node.status || 'unknown';
            const statusMatch = this.activeFilters[statusFilterKey];
            
            // Check device type filter
            const deviceType = node.device_type || 'unknown';
            const typeFilterKey = deviceType === 'unknown' ? 'unknown-type' : deviceType;
            const typeMatch = this.activeFilters[typeFilterKey];
            
            // Both status and device type must match (AND logic)
            return statusMatch && typeMatch;
        });
        
        // Filter links to only include connections between visible nodes
        const visibleNodeIds = new Set(this.nodes.map(n => n.id));
        this.links = this.allLinksData.filter(link => {
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            return visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId);
        });
        
        console.log(`TopologyFilter: Filtered to ${this.nodes.length} nodes and ${this.links.length} links`);
        
        // Update simulation with filtered data
        this.simulation.nodes(this.nodes);
        this.simulation.force('link').links(this.links);
        
        // Re-render the graph
        this.render();
        
        // Update statistics with filtered data
        this.updateFilteredStats();
        
        // Update filter summary
        this.updateFilterSummary();
    }
    
    updateFilteredStats() {
        const upCount = this.nodes.filter(n => n.status === 'up').length;
        const downCount = this.nodes.filter(n => n.status === 'down').length;
        const warningCount = this.nodes.filter(n => n.status === 'warning').length;
        const unknownCount = this.nodes.filter(n => n.status === 'unknown').length;
        const totalCount = this.nodes.length;
        const alertCount = this.nodes.reduce((sum, n) => sum + (n.active_alerts || 0), 0);
        
        // Count by device type
        const typeStats = {
            router: this.nodes.filter(n => n.device_type === 'router').length,
            computer: this.nodes.filter(n => n.device_type === 'computer').length,
            apple: this.nodes.filter(n => n.device_type === 'apple').length,
            phone: this.nodes.filter(n => n.device_type === 'phone').length,
            smart_home: this.nodes.filter(n => n.device_type === 'smart_home').length,
            iot: this.nodes.filter(n => n.device_type === 'iot').length,
            camera: this.nodes.filter(n => n.device_type === 'camera').length,
            unknown: this.nodes.filter(n => !n.device_type || n.device_type === 'unknown').length
        };
        
        // Update overview cards
        document.getElementById('overview-total').textContent = totalCount;
        document.getElementById('overview-up').textContent = upCount;
        document.getElementById('overview-down').textContent = downCount;
        document.getElementById('overview-alerts').textContent = alertCount;
        
        console.log(`TopologyFilter: Stats updated - Total: ${totalCount}, Up: ${upCount}, Down: ${downCount}, Warning: ${warningCount}, Unknown: ${unknownCount}`);
        console.log('TopologyFilter: Device Type Stats', typeStats);
    }
    
    updateFilterSummary() {
        const totalDevices = this.allNodesData.length;
        const visibleDevices = this.nodes.length;
        const summaryContainer = document.getElementById('filter-summary-container');
        const summaryText = document.getElementById('filter-summary-text');
        
        if (visibleDevices === totalDevices) {
            // All devices visible, hide summary
            summaryContainer.style.display = 'none';
            summaryText.textContent = 'Showing all devices';
            return;
        }
        
        // Some filters are active, show summary
        summaryContainer.style.display = 'block';
        
        // Build filter description
        const activeStatusFilters = [];
        const activeTypeFilters = [];
        
        // Check which status filters are active
        if (this.activeFilters.up && !this.activeFilters.down && !this.activeFilters.warning && !this.activeFilters.unknown) {
            activeStatusFilters.push('Online');
        } else if (!this.activeFilters.up && this.activeFilters.down && !this.activeFilters.warning && !this.activeFilters.unknown) {
            activeStatusFilters.push('Offline');
        } else if (!this.activeFilters.up && !this.activeFilters.down && this.activeFilters.warning && !this.activeFilters.unknown) {
            activeStatusFilters.push('Warning');
        } else if (!this.activeFilters.up && !this.activeFilters.down && !this.activeFilters.warning && this.activeFilters.unknown) {
            activeStatusFilters.push('Unknown');
        } else {
            // Multiple status filters, just show count
            const statusCount = [this.activeFilters.up, this.activeFilters.down, this.activeFilters.warning, this.activeFilters.unknown].filter(Boolean).length;
            if (statusCount < 4) {
                activeStatusFilters.push(`${statusCount} status types`);
            }
        }
        
        // Check which device type filters are active
        const typeMap = {
            router: 'Routers',
            computer: 'Computers', 
            apple: 'Apple devices',
            phone: 'Mobile devices',
            smart_home: 'Smart home',
            iot: 'IoT devices',
            camera: 'Cameras',
            'unknown-type': 'Unknown types'
        };
        
        const activeTypes = Object.entries(this.activeFilters)
            .filter(([key, value]) => value && typeMap[key])
            .map(([key]) => typeMap[key]);
            
        if (activeTypes.length === 1) {
            activeTypeFilters.push(activeTypes[0]);
        } else if (activeTypes.length > 1 && activeTypes.length < 8) {
            activeTypeFilters.push(`${activeTypes.length} device types`);
        }
        
        // Build summary text
        let summaryParts = [];
        if (activeStatusFilters.length > 0) {
            summaryParts.push(activeStatusFilters[0]);
        }
        if (activeTypeFilters.length > 0) {
            summaryParts.push(activeTypeFilters[0]);
        }
        
        const filterDesc = summaryParts.length > 0 ? ` (${summaryParts.join(', ')})` : '';
        summaryText.textContent = `Showing ${visibleDevices} of ${totalDevices} devices${filterDesc}`;
    }
    
    // updateFilterUI method removed - now using checkbox synchronization instead
    
    
    render() {
        // Update links with smooth transitions
        const link = this.linkGroup.selectAll('.link')
            .data(this.links, d => `${d.source.id || d.source}-${d.target.id || d.target}`);
            
        // Remove old links with fade out
        link.exit()
            .transition()
            .duration(300)
            .attr('stroke-opacity', 0)
            .remove();
        
        // Add new links with fade in and enhanced styling
        const linkEnter = link.enter().append('line')
            .attr('class', 'link')
            .attr('stroke', d => d.color || 'var(--topology-border-medium)')
            .attr('stroke-width', d => Math.sqrt(d.strength || 1) * 2.5)
            .attr('stroke-opacity', 0)
            .attr('stroke-linecap', 'round')
            .style('filter', 'drop-shadow(1px 1px 2px rgba(0,0,0,0.1))');
            
        linkEnter.transition()
            .duration(300)
            .attr('stroke-opacity', 0.6);
        
        // Update nodes with smooth transitions
        const node = this.nodeGroup.selectAll('.node')
            .data(this.nodes, d => d.id);
            
        // Remove old nodes with fade out and scale down
        node.exit()
            .transition()
            .duration(300)
            .style('opacity', 0)
            .attr('transform', d => `translate(${d.x},${d.y}) scale(0.1)`)
            .remove();
        
        const nodeEnter = node.enter().append('g')
            .attr('class', d => `node node-status-${d.status || 'unknown'}`)
            .style('cursor', 'pointer')
            .style('opacity', 0)
            .attr('transform', d => `translate(${d.x || this.width/2},${d.y || this.height/2}) scale(0.1)`);
            
        // Add circles with modern styling
        nodeEnter.append('circle')
            .attr('r', d => d.size || 20)
            .attr('fill', d => this.getNodeColor(d.status))
            .attr('stroke', 'var(--topology-surface)')
            .attr('stroke-width', 3)
            .style('filter', 'drop-shadow(2px 2px 4px rgba(0,0,0,0.1))');
            
        // Animate new nodes in
        nodeEnter.transition()
            .duration(300)
            .style('opacity', 1)
            .attr('transform', d => `translate(${d.x || this.width/2},${d.y || this.height/2}) scale(1)`);
            
        // Add icons based on device type using Bootstrap Icons
        nodeEnter.append('g')
            .attr('class', 'device-icon')
            .attr('transform', 'translate(0, 0)')
            .each(function(d) {
                const iconGroup = d3.select(this);
                const iconClass = networkGraph.getDeviceTypeIcon(d.device_type);
                
                // Create a foreign object to embed HTML/CSS icon
                iconGroup.append('foreignObject')
                    .attr('x', -10)
                    .attr('y', -10)
                    .attr('width', 20)
                    .attr('height', 20)
                    .html(`<div class="d-flex align-items-center justify-content-center h-100">
                        <i class="bi ${iconClass}" style="font-size: 14px; color: var(--topology-text-inverse);"></i>
                    </div>`);
            });
            
        // Add labels
        nodeEnter.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', d => d.size + 20)
            .attr('font-size', '12px')
            .attr('fill', '#333')
            .text(d => d.label.length > 15 ? d.label.substring(0, 15) + '...' : d.label);
            
        // Add click handlers
        nodeEnter.on('click', (event, d) => this.onNodeClick(event, d))
            .on('mouseover', (event, d) => this.onNodeHover(event, d))
            .on('mouseout', (event, d) => this.onNodeHoverOut(event, d));
            
        // Add drag behavior
        nodeEnter.call(d3.drag()
            .on('start', (event, d) => this.dragstarted(event, d))
            .on('drag', (event, d) => this.dragged(event, d))
            .on('end', (event, d) => this.dragended(event, d)));
        
        // Update simulation
        this.simulation.on('tick', () => {
            // Apply boundary constraints to nodes during force simulation
            this.nodes.forEach(d => {
                const nodeSize = 30;
                const margin = this.margin;
                d.x = Math.max(margin + nodeSize, Math.min(this.width - margin - nodeSize, d.x));
                d.y = Math.max(margin + nodeSize, Math.min(this.height - margin - nodeSize, d.y));
            });
            
            this.linkGroup.selectAll('.link')
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
                
            this.nodeGroup.selectAll('.node')
                .attr('transform', d => `translate(${d.x},${d.y})`);
        });
        
        // Apply layout
        this.setLayout(this.currentLayout);
    }
    
    setLayout(layout, animated = true) {
        this.currentLayout = layout;
        this.showLayoutFeedback(layout);
        
        // Clear any existing forces
        this.simulation.stop();
        
        switch (layout) {
            case 'force':
                this.applyForceDirectedLayout(animated);
                break;
            case 'circle':
                this.applyCircularLayout(animated);
                break;
            case 'grid':
                this.applyGridLayout(animated);
                break;
            case 'auto':
                this.applyIntelligentAutoLayout(animated);
                break;
            default:
                this.applyIntelligentAutoLayout(animated);
                break;
        }
    }
    
    showLayoutFeedback(layoutType) {
        const feedbackMessages = {
            'force': '🌀 Applying Physics-Based Force Layout...',
            'circle': '⭕ Creating Hierarchical Circular Arrangement...',
            'grid': '📋 Organizing Smart Grid Layout...',
            'auto': '🧠 Calculating Intelligent Auto-Layout...'
        };
        
        // Show brief feedback (you could enhance this with a toast or status bar)
        console.log(feedbackMessages[layoutType] || '🎯 Applying Layout...');
        
        // Add visual loading indicator
        this.svg.append('text')
            .attr('class', 'layout-feedback')
            .attr('x', this.width / 2)
            .attr('y', 50)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .style('fill', 'var(--topology-primary)')
            .style('font-weight', '600')
            .text(feedbackMessages[layoutType] || 'Applying Layout...')
            .transition()
            .duration(2000)
            .style('opacity', 0)
            .remove();
    }
    
    applyForceDirectedLayout(animated = true) {
        // Simple, stable force-directed layout
        
        // Clear any fixed positions
        this.nodes.forEach(d => {
            d.fx = null;
            d.fy = null;
        });
        
        // Apply simple, stable forces
        this.simulation
            .force('charge', d3.forceManyBody().strength(-300))
            .force('collision', d3.forceCollide().radius(35).strength(0.8))
            .force('center', d3.forceCenter(this.width / 2, this.height / 2).strength(0.3));
        
        // Add link forces if we have connections
        if (this.links && this.links.length > 0) {
            this.simulation.force('link', d3.forceLink(this.links)
                .id(d => d.id)
                .distance(120)
                .strength(0.5));
        } else {
            this.simulation.force('link', null);
        }
        
        // Start simulation
        this.simulation.alpha(0.5).restart();
        
        if (animated) {
            // Simple fade in animation
            this.nodeGroup.selectAll('.node')
                .style('opacity', 0.7)
                .transition()
                .duration(800)
                .style('opacity', 1);
        }
    }
    
    applyCircularLayout(animated = true) {
        // Simple circular layout - arrange nodes in concentric circles
        
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const nodeCount = this.nodes.length;
        
        // Calculate optimal circle parameters
        const maxRadius = Math.min(this.width, this.height) / 2 - this.margin - 60;
        const minRadius = 80;
        
        // Determine how many circles we need
        let circleCount = 1;
        let nodesPerCircle = nodeCount;
        
        if (nodeCount > 12) {
            circleCount = Math.ceil(nodeCount / 12);
            nodesPerCircle = Math.ceil(nodeCount / circleCount);
        }
        
        // Position nodes in circles
        this.nodes.forEach((node, index) => {
            const circleIndex = Math.floor(index / nodesPerCircle);
            const nodeInCircle = index % nodesPerCircle;
            const totalInThisCircle = Math.min(nodesPerCircle, nodeCount - (circleIndex * nodesPerCircle));
            
            // Calculate radius for this circle
            const radius = circleCount === 1 ? 
                Math.min(maxRadius, minRadius + (nodeCount * 8)) : 
                minRadius + (circleIndex / (circleCount - 1)) * (maxRadius - minRadius);
            
            // Calculate angle with some offset to prevent overlap
            const angleOffset = circleIndex * 0.3; // Offset each circle
            const angle = (nodeInCircle / totalInThisCircle) * 2 * Math.PI + angleOffset;
            
            // Calculate position
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            if (animated) {
                // Set target positions for smooth transition
                node.fx = x;
                node.fy = y;
                
                // Use brief simulation for smooth movement
                setTimeout(() => {
                    node.x = x;
                    node.y = y;
                }, index * 50);
            } else {
                node.x = x;
                node.y = y;
                node.fx = x;
                node.fy = y;
            }
        });
        
        // Use minimal forces for smooth positioning with animation
        if (animated) {
            this.simulation
                .force('charge', null)
                .force('link', null)
                .force('collision', d3.forceCollide().radius(40).strength(0.3))
                .force('center', null)
                .alpha(0.3).restart();
        } else {
            this.simulation
                .force('charge', null)
                .force('link', null)
                .force('collision', null)
                .force('center', null)
                .alpha(0).restart();
        }
    }
    
    applyGridLayout(animated = true) {
        // Simple grid layout - arrange nodes in a clean grid pattern
        
        const nodeCount = this.nodes.length;
        const margin = this.margin + 20;
        const nodeSpacing = 90;
        
        // Calculate optimal grid dimensions
        const cols = Math.ceil(Math.sqrt(nodeCount));
        const rows = Math.ceil(nodeCount / cols);
        
        // Calculate starting positions to center the grid
        const gridWidth = (cols - 1) * nodeSpacing;
        const gridHeight = (rows - 1) * nodeSpacing;
        const startX = (this.width - gridWidth) / 2;
        const startY = (this.height - gridHeight) / 2;
        
        // Position nodes in grid
        this.nodes.forEach((node, index) => {
            const col = index % cols;
            const row = Math.floor(index / cols);
            
            const x = startX + (col * nodeSpacing);
            const y = startY + (row * nodeSpacing);
            
            // Ensure within bounds
            const constrainedPos = this.constrainToViewport(x, y);
            
            if (animated) {
                // Set target positions for smooth transition
                node.fx = constrainedPos.x;
                node.fy = constrainedPos.y;
                
                // Use brief simulation for smooth movement
                setTimeout(() => {
                    node.x = constrainedPos.x;
                    node.y = constrainedPos.y;
                }, index * 30);
            } else {
                node.x = constrainedPos.x;
                node.y = constrainedPos.y;
                node.fx = constrainedPos.x;
                node.fy = constrainedPos.y;
            }
        });
        
        // Use minimal forces for smooth positioning with animation
        if (animated) {
            this.simulation
                .force('charge', null)
                .force('link', null)
                .force('collision', d3.forceCollide().radius(40).strength(0.3))
                .force('center', null)
                .alpha(0.3).restart();
        } else {
            this.simulation
                .force('charge', null)
                .force('link', null)
                .force('collision', null)
                .force('center', null)
                .alpha(0).restart();
        }
    }
    
    applyIntelligentAutoLayout(animated = true) {
        // Smart auto layout - chooses the best layout based on node count and relationships
        
        const nodeCount = this.nodes.length;
        const hasLinks = this.links && this.links.length > 0;
        
        // Choose layout based on characteristics
        if (nodeCount <= 8) {
            // Small networks: Use circle for clean presentation
            this.applyCircularLayout(animated);
            return;
        } else if (nodeCount <= 20 && hasLinks) {
            // Medium networks with connections: Use force for natural clustering
            this.applyForceDirectedLayout(animated);
            return;
        } else {
            // Large networks or no connections: Use grid for organization
            this.applyGridLayout(animated);
            return;
        }
    }
    
    onNodeClick(event, d) {
        // Navigate to device detail page
        window.location.href = `/device/${d.id}`;
    }
    
    onNodeHover(event, d) {
        // Highlight node
        d3.select(event.currentTarget).select('circle')
            .attr('stroke-width', 4)
            .attr('stroke', '#007bff');
        
        // Show tooltip with device details
        this.showTooltip(event, d);
    }
    
    onNodeHoverOut(event, d) {
        // Remove highlight
        d3.select(event.currentTarget).select('circle')
            .attr('stroke-width', 2)
            .attr('stroke', '#fff');
        
        // Hide tooltip
        this.hideTooltip();
    }
    
    dragstarted(event, d) {
        if (!event.active) this.simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }
    
    dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }
    
    dragended(event, d) {
        if (!event.active) this.simulation.alphaTarget(0);
        // Keep the node fixed at its current position - don't reset fx/fy
        // d.fx = null;
        // d.fy = null;
    }
    
    refresh() {
        this.loadData();
    }
    
    resize() {
        const container = this.container.node();
        this.width = container.clientWidth;
        this.height = container.clientHeight;
        
        this.svg.attr('viewBox', `0 0 ${this.width} ${this.height}`);
        this.simulation.force('center', d3.forceCenter(this.width / 2, this.height / 2));
        this.simulation.alpha(0.3).restart();
    }
    
    // Initialize filter event handlers with new checkbox approach
    initializeFilterHandlers() {
        // Status filter checkboxes
        const statusCheckboxes = {
            'status-online': 'up',
            'status-offline': 'down',
            'status-warning': 'warning',
            'status-unknown': 'unknown'
        };
        
        // Device type filter checkboxes
        const typeCheckboxes = {
            'type-router': 'router',
            'type-computer': 'computer',
            'type-apple': 'apple',
            'type-phone': 'phone',
            'type-smart_home': 'smart_home',
            'type-iot': 'iot',
            'type-camera': 'camera',
            'type-unknown': 'unknown-type'
        };
        
        // Add event listeners to status checkboxes
        Object.entries(statusCheckboxes).forEach(([checkboxId, filterKey]) => {
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.addEventListener('change', (e) => {
                    this.activeFilters[filterKey] = e.target.checked;
                    this.applyFilters();
                });
            }
        });
        
        // Add event listeners to device type checkboxes
        Object.entries(typeCheckboxes).forEach(([checkboxId, filterKey]) => {
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.addEventListener('change', (e) => {
                    this.activeFilters[filterKey] = e.target.checked;
                    this.applyFilters();
                });
            }
        });
        
        // Select All / Clear All buttons
        document.getElementById('select-all-filters')?.addEventListener('click', () => {
            this.selectAllFilters();
        });
        
        document.getElementById('clear-all-filters')?.addEventListener('click', () => {
            this.clearAllFilters();
        });
        
        // Reset filters button
        document.getElementById('reset-filters')?.addEventListener('click', () => {
            this.resetFilters();
        });
        
        console.log('Topology: Checkbox filter handlers initialized');
    }
    
    selectAllFilters() {
        // Check all checkboxes
        Object.keys(this.activeFilters).forEach(key => {
            this.activeFilters[key] = true;
        });
        
        // Update UI checkboxes
        this.syncCheckboxes();
        this.applyFilters();
    }
    
    clearAllFilters() {
        // Uncheck all checkboxes
        Object.keys(this.activeFilters).forEach(key => {
            this.activeFilters[key] = false;
        });
        
        // Update UI checkboxes
        this.syncCheckboxes();
        this.applyFilters();
    }
    
    resetFilters() {
        // Reset to all filters active
        this.selectAllFilters();
    }
    
    syncCheckboxes() {
        // Sync checkbox UI with filter state
        const checkboxMap = {
            'status-online': 'up',
            'status-offline': 'down',
            'status-warning': 'warning',
            'status-unknown': 'unknown',
            'type-router': 'router',
            'type-computer': 'computer',
            'type-apple': 'apple',
            'type-phone': 'phone',
            'type-smart_home': 'smart_home',
            'type-iot': 'iot',
            'type-camera': 'camera',
            'type-unknown': 'unknown-type'
        };
        
        Object.entries(checkboxMap).forEach(([checkboxId, filterKey]) => {
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.checked = this.activeFilters[filterKey];
            }
        });
    }
    
    autoArrange() {
        // Smart auto-arrange based on device types, status, and relationships
        const margin = 80;
        const groupSpacing = 120;
        const deviceSpacing = 100;
        
        // Group devices by type and status
        const deviceGroups = {
            'core': [],      // routers, switches, core infrastructure
            'servers': [],   // computers, servers
            'smart_home': [],// smart home devices
            'cameras': [],   // security cameras
            'mobile': [],    // phones, tablets, mobile devices
            'unknown': []    // unknown or other devices
        };
        
        // Categorize devices into logical groups based on device_type field
        this.nodes.forEach(node => {
            const type = (node.device_type || 'unknown').toLowerCase();
            
            // Core infrastructure (highest priority)
            if (type === 'router') {
                deviceGroups.core.push(node);
            }
            // Servers and computers
            else if (type === 'computer') {
                deviceGroups.servers.push(node);
            }
            // Smart home and IoT devices
            else if (type === 'smart_home' || type === 'iot') {
                deviceGroups.smart_home.push(node);
            }
            // Security cameras
            else if (type === 'camera') {
                deviceGroups.cameras.push(node);
            }
            // Mobile devices (phones, tablets, Apple devices)
            else if (type === 'phone' || type === 'apple') {
                deviceGroups.mobile.push(node);
            }
            // Everything else goes to unknown
            else {
                deviceGroups.unknown.push(node);
            }
        });
        
        // Sort each group: online first, then warning, then offline
        const statusOrder = { 'up': 0, 'warning': 1, 'down': 2, 'unknown': 3 };
        Object.values(deviceGroups).forEach(group => {
            group.sort((a, b) => {
                const statusDiff = statusOrder[a.status] - statusOrder[b.status];
                if (statusDiff !== 0) return statusDiff;
                return a.label.localeCompare(b.label); // Secondary sort by name
            });
        });
        
        // Calculate layout positions
        let currentY = margin;
        const centerX = this.width / 2;
        
        // Position core infrastructure at the top center
        if (deviceGroups.core.length > 0) {
            this.positionGroup(deviceGroups.core, centerX, currentY, deviceSpacing, 'horizontal');
            currentY += groupSpacing;
        }
        
        // Position servers in the second tier
        if (deviceGroups.servers.length > 0) {
            this.positionGroup(deviceGroups.servers, centerX, currentY, deviceSpacing, 'horizontal');
            currentY += groupSpacing;
        }
        
        // Position other groups in rows below
        const remainingGroups = ['smart_home', 'cameras', 'mobile', 'unknown'].filter(key => deviceGroups[key].length > 0);
        
        if (remainingGroups.length > 0) {
            const groupsPerRow = Math.min(2, remainingGroups.length);
            const groupWidth = (this.width - 2 * margin) / groupsPerRow;
            
            for (let i = 0; i < remainingGroups.length; i += groupsPerRow) {
                const rowGroups = remainingGroups.slice(i, i + groupsPerRow);
                
                rowGroups.forEach((groupKey, index) => {
                    const group = deviceGroups[groupKey];
                    const x = margin + (index + 0.5) * groupWidth;
                    this.positionGroup(group, x, currentY, deviceSpacing * 0.8, 'grid');
                });
                
                currentY += groupSpacing;
            }
        }
        
        // Restart simulation with the new positions
        this.simulation.alpha(0.3).restart();
    }
    
    positionGroup(devices, centerX, startY, spacing, layout) {
        if (devices.length === 0) return;
        
        if (layout === 'horizontal') {
            // Arrange devices in a horizontal line
            const totalWidth = (devices.length - 1) * spacing;
            const startX = centerX - totalWidth / 2;
            
            devices.forEach((device, index) => {
                device.fx = startX + index * spacing;
                device.fy = startY;
            });
        } else if (layout === 'grid') {
            // Arrange devices in a compact grid
            const cols = Math.ceil(Math.sqrt(devices.length));
            const rows = Math.ceil(devices.length / cols);
            const gridSpacing = spacing * 0.7;
            
            devices.forEach((device, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                const gridWidth = (cols - 1) * gridSpacing;
                const gridHeight = (rows - 1) * gridSpacing;
                
                device.fx = centerX - gridWidth / 2 + col * gridSpacing;
                device.fy = startY - gridHeight / 2 + row * gridSpacing;
            });
        }
    }
    
    resetPositions() {
        // Clear all fixed positions and restart with current layout
        this.nodes.forEach(d => {
            d.fx = null;
            d.fy = null;
        });
        this.setLayout(this.currentLayout);
    }
    
    // ========================================
    // Advanced Layout Utility Methods
    // ========================================
    
    calculateNodeCentrality() {
        // Calculate betweenness and degree centrality for nodes
        const centralityMap = new Map();
        
        this.nodes.forEach(node => {
            // Count connections (degree centrality)
            const connections = this.links.filter(link => 
                link.source.id === node.id || link.target.id === node.id
            ).length;
            
            // Simple centrality based on connections and device type importance
            let importance = connections;
            
            // Router and core infrastructure nodes are more important
            if (node.device_type === 'router') importance *= 3;
            if (node.device_type === 'computer') importance *= 2;
            if (node.status === 'up') importance *= 1.5;
            if (node.ip_address && node.ip_address.endsWith('.1')) importance *= 2; // Gateway
            
            centralityMap.set(node.id, importance);
        });
        
        return centralityMap;
    }
    
    groupNodesByTypeAndImportance() {
        const groups = {
            'core': [],        // Routers, gateways
            'infrastructure': [], // Important computers, servers
            'smart_devices': [],  // IoT, smart home
            'endpoints': [],     // Phones, tablets
            'unknown': []        // Unknown devices
        };
        
        this.nodes.forEach(node => {
            if (node.device_type === 'router' || node.ip_address?.endsWith('.1')) {
                groups.core.push(node);
            } else if (node.device_type === 'computer') {
                groups.infrastructure.push(node);
            } else if (['smart_home', 'iot', 'camera'].includes(node.device_type)) {
                groups.smart_devices.push(node);
            } else if (['phone', 'apple'].includes(node.device_type)) {
                groups.endpoints.push(node);
            } else {
                groups.unknown.push(node);
            }
        });
        
        // Remove empty groups
        Object.keys(groups).forEach(key => {
            if (groups[key].length === 0) {
                delete groups[key];
            }
        });
        
        return groups;
    }
    
    groupNodesByType() {
        const groups = {};
        
        this.nodes.forEach(node => {
            const type = node.device_type || 'unknown';
            if (!groups[type]) {
                groups[type] = [];
            }
            groups[type].push(node);
        });
        
        return groups;
    }
    
    transitionNodeToPosition(node, targetX, targetY, delay = 0) {
        // Smooth transition animation for individual nodes
        const startX = node.x || this.width / 2;
        const startY = node.y || this.height / 2;
        
        // Use D3 interpolation for smooth movement
        const interpolateX = d3.interpolate(startX, targetX);
        const interpolateY = d3.interpolate(startY, targetY);
        
        d3.select(`[node-id="${node.id}"]`)
            .transition()
            .delay(delay)
            .duration(1000)
            .ease(d3.easeCubicOut)
            .tween('position', () => {
                return (t) => {
                    node.x = interpolateX(t);
                    node.y = interpolateY(t);
                    node.fx = node.x;
                    node.fy = node.y;
                };
            });
    }
    
    createIntelligentGroups() {
        // AI-inspired grouping based on multiple factors
        const groups = {
            'network_core': [],    // Critical infrastructure
            'compute_cluster': [], // Computers and servers
            'smart_ecosystem': [], // Connected devices
            'mobile_devices': [],  // Portable devices
            'peripherals': []      // Everything else
        };
        
        this.nodes.forEach(node => {
            const score = this.calculateIntelligenceScore(node);
            
            if (node.device_type === 'router' || node.ip_address?.endsWith('.1')) {
                groups.network_core.push(node);
            } else if (node.device_type === 'computer' || score.computational > 0.7) {
                groups.compute_cluster.push(node);
            } else if (['smart_home', 'iot', 'camera'].includes(node.device_type)) {
                groups.smart_ecosystem.push(node);
            } else if (['phone', 'apple'].includes(node.device_type) || score.mobility > 0.7) {
                groups.mobile_devices.push(node);
            } else {
                groups.peripherals.push(node);
            }
        });
        
        return groups;
    }
    
    calculateIntelligenceScore(node) {
        // Multi-factor scoring for intelligent placement
        return {
            importance: this.calculateNodeImportance(node),
            connectivity: this.calculateConnectivityScore(node),
            computational: this.calculateComputationalScore(node),
            mobility: this.calculateMobilityScore(node)
        };
    }
    
    calculateNodeImportance(node) {
        let score = 0;
        
        // Connection count
        const connections = this.links.filter(l => 
            l.source.id === node.id || l.target.id === node.id
        ).length;
        score += Math.min(connections / 10, 1); // Max 1.0 for connections
        
        // Device type importance
        const typeScores = {
            'router': 1.0,
            'computer': 0.8,
            'smart_home': 0.6,
            'camera': 0.7,
            'phone': 0.4,
            'iot': 0.5,
            'unknown': 0.2
        };
        score += typeScores[node.device_type] || 0.2;
        
        // Status importance
        if (node.status === 'up') score += 0.3;
        
        // Network position (gateway IPs are important)
        if (node.ip_address?.endsWith('.1')) score += 0.5;
        
        return Math.min(score, 2.0); // Cap at 2.0
    }
    
    calculateConnectivityScore(node) {
        const connections = this.links.filter(l => 
            l.source.id === node.id || l.target.id === node.id
        ).length;
        return Math.min(connections / 5, 1.0);
    }
    
    calculateComputationalScore(node) {
        const scores = {
            'router': 0.9,
            'computer': 1.0,
            'smart_home': 0.3,
            'camera': 0.4,
            'phone': 0.6,
            'apple': 0.7,
            'iot': 0.2
        };
        return scores[node.device_type] || 0.1;
    }
    
    calculateMobilityScore(node) {
        const scores = {
            'phone': 1.0,
            'apple': 0.8,
            'computer': 0.2, // Could be laptop
            'router': 0.0,
            'camera': 0.1,
            'smart_home': 0.0,
            'iot': 0.1
        };
        return scores[node.device_type] || 0.1;
    }
    
    calculateOptimalLayoutParameters(groups) {
        const totalNodes = this.nodes.length;
        const availableWidth = this.width - 160; // Margins
        const availableHeight = this.height - 160;
        
        return {
            nodeSpacing: Math.max(80, Math.min(150, availableWidth / Math.sqrt(totalNodes))),
            groupSpacing: Math.max(100, availableWidth / Object.keys(groups).length / 3),
            verticalSpacing: Math.max(80, availableHeight / Math.ceil(Object.keys(groups).length / 2))
        };
    }
    
    positionGroupsHierarchically(groups, config, animated) {
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const groupKeys = Object.keys(groups);
        
        // Position groups in a smart hierarchy
        groupKeys.forEach((groupKey, groupIndex) => {
            const groupNodes = groups[groupKey];
            const groupImportance = this.calculateGroupImportance(groupKey, groupNodes);
            
            // Calculate group position based on importance
            let groupCenterX, groupCenterY;
            
            if (groupKey === 'network_core') {
                // Core goes in center
                groupCenterX = centerX;
                groupCenterY = centerY;
            } else {
                // Other groups arranged around core
                const angle = (groupIndex / groupKeys.length) * 2 * Math.PI;
                const distance = 150 + (groupImportance * 100);
                groupCenterX = centerX + Math.cos(angle) * distance;
                groupCenterY = centerY + Math.sin(angle) * distance;
            }
            
            // Position nodes within group
            this.positionNodesInGroup(groupNodes, groupCenterX, groupCenterY, config, animated);
        });
    }
    
    calculateGroupImportance(groupKey, nodes) {
        const importanceMap = {
            'network_core': 1.0,
            'compute_cluster': 0.8,
            'smart_ecosystem': 0.6,
            'mobile_devices': 0.4,
            'peripherals': 0.2
        };
        
        const baseImportance = importanceMap[groupKey] || 0.3;
        const sizeBonus = Math.min(nodes.length / 10, 0.3);
        
        return baseImportance + sizeBonus;
    }
    
    positionNodesInGroup(nodes, centerX, centerY, config, animated) {
        const nodeCount = nodes.length;
        
        if (nodeCount === 1) {
            // Single node at center
            const node = nodes[0];
            const constrainedPos = this.constrainToViewport(centerX, centerY);
            if (animated) {
                this.transitionNodeToPosition(node, constrainedPos.x, constrainedPos.y, 0);
            } else {
                node.x = constrainedPos.x;
                node.y = constrainedPos.y;
                node.fx = constrainedPos.x;
                node.fy = constrainedPos.y;
            }
            return;
        }
        
        // Multiple nodes in circular arrangement around group center
        const radius = Math.max(40, config.nodeSpacing / 2);
        
        nodes.forEach((node, index) => {
            const angle = (index / nodeCount) * 2 * Math.PI;
            const targetX = centerX + Math.cos(angle) * radius;
            const targetY = centerY + Math.sin(angle) * radius;
            const constrainedPos = this.constrainToViewport(targetX, targetY);
            
            if (animated) {
                this.transitionNodeToPosition(node, constrainedPos.x, constrainedPos.y, index * 100);
            } else {
                node.x = constrainedPos.x;
                node.y = constrainedPos.y;
                node.fx = constrainedPos.x;
                node.fy = constrainedPos.y;
            }
        });
    }
    
    // ========================================
    // Zoom and Pan Functionality
    // ========================================
    
    zoomIn() {
        this.svg.transition().duration(500).call(
            this.zoom.scaleBy, 1.5
        );
    }
    
    zoomOut() {
        this.svg.transition().duration(500).call(
            this.zoom.scaleBy, 1 / 1.5
        );
    }
    
    zoomToFit(padding = 50) {
        if (this.nodes.length === 0) return;
        
        // Calculate bounds of all nodes
        const bounds = this.calculateNodeBounds();
        
        // Calculate scale to fit all nodes with padding
        const scale = Math.min(
            (this.width - padding * 2) / (bounds.width || this.width),
            (this.height - padding * 2) / (bounds.height || this.height)
        );
        
        // Calculate center translation
        const centerX = bounds.x + bounds.width / 2;
        const centerY = bounds.y + bounds.height / 2;
        const translateX = this.width / 2 - centerX * scale;
        const translateY = this.height / 2 - centerY * scale;
        
        // Apply transform smoothly
        this.svg.transition()
            .duration(1000)
            .call(
                this.zoom.transform,
                d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale)
            );
    }
    
    calculateNodeBounds() {
        if (this.nodes.length === 0) {
            return { x: 0, y: 0, width: this.width, height: this.height };
        }
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        this.nodes.forEach(node => {
            const x = node.x || 0;
            const y = node.y || 0;
            const size = (node.size || 20) + 20; // Add padding for node size
            
            minX = Math.min(minX, x - size);
            minY = Math.min(minY, y - size);
            maxX = Math.max(maxX, x + size);
            maxY = Math.max(maxY, y + size);
        });
        
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
    }
    
    constrainToViewport(x, y) {
        // Ensure nodes stay within viewport boundaries with margin
        const nodeSize = 30; // Account for node size and padding
        
        return {
            x: Math.max(this.margin + nodeSize, Math.min(this.width - this.margin - nodeSize, x)),
            y: Math.max(this.margin + nodeSize, Math.min(this.height - this.margin - nodeSize, y))
        };
    }
    
    // Enhanced cursor management
    setCursor(cursorType) {
        this.svg.style('cursor', cursorType);
    }
    
    showTooltip(event, d) {
        const tooltip = document.getElementById('device-tooltip');
        if (!tooltip) return;
        
        // Update tooltip content with device type-specific icon
        const iconElement = document.getElementById('tooltip-icon');
        const nameElement = document.getElementById('tooltip-name');
        const ipElement = document.getElementById('tooltip-ip');
        
        if (iconElement) {
            const iconClass = this.getDeviceTypeIcon(d.device_type);
            iconElement.innerHTML = `<i class="bi ${iconClass}" style="font-size: 1.2em;"></i>`;
        }
        if (nameElement) nameElement.textContent = d.label || 'Unknown Device';
        if (ipElement) ipElement.textContent = d.ip || 'Unknown IP';
        
        // Update status badge
        const statusBadge = document.getElementById('tooltip-status');
        if (statusBadge) {
            statusBadge.textContent = d.status ? d.status.toUpperCase() : 'UNKNOWN';
            statusBadge.className = `ms-auto badge ${
                d.status === 'up' ? 'bg-success' :
                d.status === 'down' ? 'bg-danger' :
                d.status === 'warning' ? 'bg-warning' :
                'bg-secondary'
            }`;
        }
        
        // Update metrics
        const responseElement = document.getElementById('tooltip-response');
        if (responseElement) {
            responseElement.textContent = d.response_time ? `${d.response_time.toFixed(1)}ms` : 'N/A';
        }
        
        const uptimeElement = document.getElementById('tooltip-uptime');
        if (uptimeElement) {
            uptimeElement.textContent = d.uptime_percentage ? `${d.uptime_percentage.toFixed(1)}%` : 'N/A';
        }
        
        // Format device type for display
        const typeElement = document.getElementById('tooltip-type');
        if (typeElement) {
            const deviceTypeDisplay = (d.device_type || 'unknown').replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
            typeElement.textContent = deviceTypeDisplay;
        }
        
        const alertsElement = document.getElementById('tooltip-alerts');
        if (alertsElement) {
            alertsElement.textContent = d.active_alerts || '0';
        }
        
        // Update last seen
        const lastSeenElement = document.getElementById('tooltip-last-seen');
        if (lastSeenElement) {
            const lastSeen = d.last_seen ? 
                new Date(d.last_seen).toLocaleString([], {
                    month: 'short', day: 'numeric', 
                    hour: '2-digit', minute: '2-digit'
                }) : 'Unknown';
            lastSeenElement.textContent = lastSeen;
        }
        
        // Position tooltip near cursor
        const rect = this.container.node().getBoundingClientRect();
        const mouseX = event.pageX - rect.left;
        const mouseY = event.pageY - rect.top;
        
        // Adjust position to keep tooltip in view
        let left = mouseX + 15;
        let top = mouseY - 100;
        
        // Prevent tooltip from going off-screen
        const tooltipWidth = 320;
        const tooltipHeight = 200;
        
        if (left + tooltipWidth > this.width) {
            left = mouseX - tooltipWidth - 15;
        }
        if (top < 0) {
            top = mouseY + 15;
        }
        if (top + tooltipHeight > this.height) {
            top = this.height - tooltipHeight - 10;
        }
        
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.style.display = 'block';
        tooltip.style.opacity = '1';
    }
    
    hideTooltip() {
        const tooltip = document.getElementById('device-tooltip');
        if (tooltip) {
            tooltip.style.display = 'none';
            tooltip.style.opacity = '0';
        }
    }
    
    getDeviceTypeIcon(deviceType) {
        // Return Bootstrap icon class names for SVG rendering
        const iconMap = {
            'router': 'bi-router',
            'computer': 'bi-pc-display',
            'apple': 'bi-apple',
            'phone': 'bi-phone',
            'smart_home': 'bi-house-gear',
            'iot': 'bi-cpu',
            'camera': 'bi-camera-video',
            'unknown': 'bi-question-circle'
        };
        
        return iconMap[deviceType] || iconMap['unknown'];
    }
    
    getNodeColor(status) {
        // Get colors from CSS custom properties
        const computedStyle = getComputedStyle(document.documentElement);
        switch (status) {
            case 'up':
                return computedStyle.getPropertyValue('--status-online').trim();
            case 'down':
                return computedStyle.getPropertyValue('--status-offline').trim();
            case 'warning':
                return computedStyle.getPropertyValue('--status-warning').trim();
            case 'unknown':
            default:
                return computedStyle.getPropertyValue('--status-unknown').trim();
        }
    }
    
    startAutoRefresh() {
        // Auto-refresh disabled to preserve node positions when moved
        // setInterval(() => {
        //     this.refresh();
        // }, 30000); // Refresh every 30 seconds
    }
    
    // Ping functionality
    async pingDevices(mode, deviceType = null) {
        let devices = [];
        let operationTitle = '';
        
        // Determine which devices to ping based on mode
        switch (mode) {
            case 'visible':
                devices = this.nodes.map(node => ({ id: node.id, name: node.label, ip: node.ip }));
                operationTitle = `Pinging ${devices.length} Visible Devices`;
                break;
                
            case 'all':
                try {
                    const response = await fetch('/api/devices?monitored=true');
                    const data = await response.json();
                    devices = data.devices.map(device => ({ 
                        id: device.id, 
                        name: device.display_name, 
                        ip: device.ip_address 
                    }));
                    operationTitle = `Pinging All ${devices.length} Monitored Devices`;
                } catch (error) {
                    console.error('Error fetching devices:', error);
                    return;
                }
                break;
                
            case 'type':
                if (!deviceType) return;
                devices = this.allNodesData
                    .filter(node => node.device_type === deviceType)
                    .map(node => ({ id: node.id, name: node.label, ip: node.ip }));
                const typeDisplay = deviceType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
                operationTitle = `Pinging ${devices.length} ${typeDisplay} Devices`;
                break;
                
            default:
                return;
        }
        
        if (devices.length === 0) {
            alert('No devices found to ping.');
            return;
        }
        
        await this.executePingOperation(devices, operationTitle);
    }
    
    async executePingOperation(devices, operationTitle) {
        // Prevent concurrent ping operations
        if (this.isPingOperationRunning) {
            console.log('Ping operation already in progress, ignoring request');
            return;
        }
        
        this.isPingOperationRunning = true;
        
        // Get or create modal instance (singleton pattern)
        if (!this.pingModal) {
            const modalElement = document.getElementById('ping-progress-modal');
            this.pingModal = bootstrap.Modal.getInstance(modalElement) || new bootstrap.Modal(modalElement);
            
            // Add event listener to reset operation lock when modal is hidden
            modalElement.addEventListener('hidden.bs.modal', () => {
                this.isPingOperationRunning = false;
            });
        }
        
        // Get DOM elements
        const progressBar = document.getElementById('ping-progress-bar');
        const progressText = document.getElementById('ping-progress-text');
        const titleElement = document.getElementById('ping-operation-title');
        const successCount = document.getElementById('ping-success-count');
        const failCount = document.getElementById('ping-fail-count');
        const remainingCount = document.getElementById('ping-remaining-count');
        const currentDevice = document.getElementById('ping-current-device');
        const cancelBtn = document.getElementById('ping-cancel-btn');
        const cancelSecondaryBtn = document.getElementById('ping-cancel-secondary-btn');
        const closeBtn = document.getElementById('ping-close-btn');
        
        // Initialize modal UI without animations first
        titleElement.textContent = operationTitle;
        progressBar.style.width = '0%';
        progressBar.className = 'progress-bar'; // Start without animations
        progressText.textContent = `0 / ${devices.length} devices`;
        successCount.textContent = '0';
        failCount.textContent = '0';
        remainingCount.textContent = devices.length.toString();
        currentDevice.textContent = 'Preparing...';
        cancelSecondaryBtn.style.display = 'inline-block';
        closeBtn.style.display = 'none';
        
        // Show modal
        this.pingModal.show();
        
        // Add animations after modal is shown to prevent flicker
        setTimeout(() => {
            progressBar.className = 'progress-bar progress-bar-striped progress-bar-animated';
        }, 150);
        
        let cancelled = false;
        let completed = 0;
        let successful = 0;
        let failed = 0;
        
        // Cancel button handlers
        const cancelHandler = () => {
            cancelled = true;
            currentDevice.textContent = 'Cancelling...';
        };
        cancelBtn.addEventListener('click', cancelHandler);
        cancelSecondaryBtn.addEventListener('click', cancelHandler);
        
        // Process devices one by one for better UX
        for (let i = 0; i < devices.length && !cancelled; i++) {
            const device = devices[i];
            currentDevice.textContent = `Pinging ${device.name}...`;
            
            // Update node to show pinging state
            this.setNodePingState(device.id, 'pinging');
            
            try {
                const response = await fetch('/api/device-control/ping', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        ip_address: device.ip,
                        count: 1
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    successful++;
                    this.setNodePingState(device.id, 'success', result.avg_response_time);
                } else {
                    failed++;
                    this.setNodePingState(device.id, 'failed');
                }
                
            } catch (error) {
                console.error(`Error pinging ${device.name}:`, error);
                failed++;
                this.setNodePingState(device.id, 'failed');
            }
            
            completed++;
            const remaining = devices.length - completed;
            
            // Update progress
            const progress = (completed / devices.length) * 100;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${completed} / ${devices.length} devices`;
            successCount.textContent = successful.toString();
            failCount.textContent = failed.toString();
            remainingCount.textContent = remaining.toString();
        }
        
        // Clean up handlers
        cancelBtn.removeEventListener('click', cancelHandler);
        cancelSecondaryBtn.removeEventListener('click', cancelHandler);
        
        // Update final state
        if (cancelled) {
            currentDevice.textContent = 'Operation cancelled';
            progressBar.classList.remove('progress-bar-animated');
            progressBar.classList.add('bg-warning');
        } else {
            currentDevice.textContent = 'Completed successfully!';
            progressBar.classList.remove('progress-bar-animated');
            progressBar.classList.add(successful === devices.length ? 'bg-success' : 'bg-info');
            
            // Show completion notification
            this.showPingCompletionNotification(successful, failed, devices.length);
        }
        
        // Show close button, hide cancel
        cancelSecondaryBtn.style.display = 'none';
        closeBtn.style.display = 'inline-block';
        closeBtn.onclick = () => {
            this.pingModal.hide();
            this.isPingOperationRunning = false;
        };
        
        // Auto-close after 10 seconds if successful
        if (!cancelled && successful > 0) {
            setTimeout(() => {
                if (this.pingModal._isShown) {
                    this.pingModal.hide();
                    this.isPingOperationRunning = false;
                }
            }, 10000);
        }
        
        // Reset operation lock if cancelled
        if (cancelled) {
            this.isPingOperationRunning = false;
        }
    }
    
    setNodePingState(deviceId, state, responseTime = null) {
        // Find the node in the current visible nodes
        const node = this.nodes.find(n => n.id === deviceId);
        if (!node) return;
        
        // Update node visual state
        const nodeElement = this.nodeGroup.selectAll('.node')
            .filter(d => d.id === deviceId);
            
        if (nodeElement.empty()) return;
        
        // Remove all ping state classes
        nodeElement.classed('node-pinging', false)
                  .classed('node-ping-success', false)
                  .classed('node-ping-failed', false);
        
        const circle = nodeElement.select('circle');
        
        switch (state) {
            case 'pinging':
                nodeElement.classed('node-pinging', true);
                circle.attr('stroke', '#007bff')
                     .attr('stroke-width', 4)
                     .style('opacity', 0.8);
                break;
                
            case 'success':
                nodeElement.classed('node-ping-success', true);
                circle.attr('stroke', '#28a745')
                     .attr('stroke-width', 3)
                     .style('opacity', 1);
                // Update node data for future reference
                node.last_ping_time = new Date().toISOString();
                node.last_ping_success = true;
                if (responseTime) {
                    node.response_time = responseTime;
                }
                // Auto-reset visual state after 3 seconds
                setTimeout(() => {
                    nodeElement.classed('node-ping-success', false);
                    circle.attr('stroke', '#fff').attr('stroke-width', 2);
                }, 3000);
                break;
                
            case 'failed':
                nodeElement.classed('node-ping-failed', true);
                circle.attr('stroke', '#dc3545')
                     .attr('stroke-width', 3)
                     .style('opacity', 1);
                // Update node data
                node.last_ping_time = new Date().toISOString();
                node.last_ping_success = false;
                // Auto-reset visual state after 3 seconds
                setTimeout(() => {
                    nodeElement.classed('node-ping-failed', false);
                    circle.attr('stroke', '#fff').attr('stroke-width', 2);
                }, 3000);
                break;
                
            default:
                circle.attr('stroke', '#fff')
                     .attr('stroke-width', 2)
                     .style('opacity', 1);
        }
    }
    
    showPingCompletionNotification(successful, failed, total) {
        const message = `Ping operation completed: ${successful} successful, ${failed} failed out of ${total} devices.`;
        
        // Create a toast notification (simple implementation)
        const toast = document.createElement('div');
        toast.className = 'toast align-items-center text-white bg-primary border-0 position-fixed';
        toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999;';
        toast.setAttribute('role', 'alert');
        toast.innerHTML = `
            <div class="d-flex">
                <div class="toast-body">
                    <i class="bi bi-broadcast me-2"></i>${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        `;
        
        document.body.appendChild(toast);
        
        // Use Bootstrap toast if available, otherwise auto-remove
        if (window.bootstrap && bootstrap.Toast) {
            const bsToast = new bootstrap.Toast(toast);
            bsToast.show();
        } else {
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 5000);
        }
    }
}

function setActiveGraphButton(activeId) {
    document.querySelectorAll('#topology-card .btn-group .btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.getElementById(activeId).classList.add('active');
}

function addButtonLoadingState(buttonId) {
    const button = document.getElementById(buttonId);
    if (!button) return;
    
    // Store original content
    button.dataset.originalContent = button.innerHTML;
    button.disabled = true;
    button.style.opacity = '0.7';
    
    // Add spinning icon
    button.innerHTML = '<i class="bi bi-arrow-repeat" style="animation: spin 1s linear infinite;"></i>';
}

function removeButtonLoadingState(buttonId) {
    const button = document.getElementById(buttonId);
    if (!button) return;
    
    // Restore original content
    button.innerHTML = button.dataset.originalContent;
    button.disabled = false;
    button.style.opacity = '1';
    delete button.dataset.originalContent;
}

// Add CSS animation for spinning icon
if (!document.querySelector('#spin-animation')) {
    const spinAnimation = document.createElement('style');
    spinAnimation.id = 'spin-animation';
    spinAnimation.textContent = `
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    `;
    document.head.appendChild(spinAnimation);
}

function toggleFullscreen() {
    const card = document.getElementById('topology-card');
    const btn = document.getElementById('fullscreen-btn');
    const icon = btn.querySelector('i');
    
    if (!isFullscreen) {
        // Enter fullscreen
        card.classList.add('fullscreen-mode');
        
        // Add exit button
        const exitBtn = document.createElement('button');
        exitBtn.className = 'btn btn-danger fullscreen-exit-btn';
        exitBtn.innerHTML = '<i class="bi bi-x-lg"></i>';
        exitBtn.onclick = toggleFullscreen;
        document.body.appendChild(exitBtn);
        
        icon.className = 'bi bi-fullscreen-exit';
        isFullscreen = true;
        
        // Resize graph
        setTimeout(() => {
            networkGraph.resize();
        }, 100);
    } else {
        // Exit fullscreen
        card.classList.remove('fullscreen-mode');
        
        // Remove exit button
        const exitBtn = document.querySelector('.fullscreen-exit-btn');
        if (exitBtn) {
            exitBtn.remove();
        }
        
        icon.className = 'bi bi-arrows-fullscreen';
        isFullscreen = false;
        
        // Resize graph
        setTimeout(() => {
            networkGraph.resize();
        }, 100);
    }
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Initialize theme
    initializeTheme();
    
    // Initialize network graph
    networkGraph = new NetworkGraph('network-graph');
    
    // Initialize filter handlers
    networkGraph.initializeFilterHandlers();
    
    // Network graph controls
    // Enhanced network graph controls with visual feedback
    document.getElementById('graph-layout-force').addEventListener('click', () => {
        addButtonLoadingState('graph-layout-force');
        setTimeout(() => {
            networkGraph.setLayout('force', true);
            setActiveGraphButton('graph-layout-force');
            removeButtonLoadingState('graph-layout-force');
        }, 100);
    });
    
    document.getElementById('graph-layout-circle').addEventListener('click', () => {
        addButtonLoadingState('graph-layout-circle');
        setTimeout(() => {
            networkGraph.setLayout('circle', true);
            setActiveGraphButton('graph-layout-circle');
            removeButtonLoadingState('graph-layout-circle');
        }, 100);
    });
    
    document.getElementById('graph-layout-grid').addEventListener('click', () => {
        addButtonLoadingState('graph-layout-grid');
        setTimeout(() => {
            networkGraph.setLayout('grid', true);
            setActiveGraphButton('graph-layout-grid');
            removeButtonLoadingState('graph-layout-grid');
        }, 100);
    });
    
    document.getElementById('graph-refresh').addEventListener('click', () => {
        addButtonLoadingState('graph-refresh');
        networkGraph.loadTopologyData();
        setTimeout(() => removeButtonLoadingState('graph-refresh'), 2000);
    });
    
    document.getElementById('graph-reset').addEventListener('click', () => {
        addButtonLoadingState('graph-reset');
        networkGraph.resetPositions();
        setTimeout(() => removeButtonLoadingState('graph-reset'), 1500);
    });
    
    document.getElementById('graph-auto-arrange').addEventListener('click', () => {
        addButtonLoadingState('graph-auto-arrange');
        setTimeout(() => {
            networkGraph.setLayout('auto', true);
            setActiveGraphButton('graph-auto-arrange');
            removeButtonLoadingState('graph-auto-arrange');
        }, 100);
    });
    
    // Ping operations with new button structure
    document.getElementById('ping-visible-devices').addEventListener('click', (e) => {
        e.preventDefault();
        networkGraph.pingDevices('visible');
    });
    
    document.getElementById('ping-all-devices').addEventListener('click', (e) => {
        e.preventDefault();
        networkGraph.pingDevices('all');
    });
    
    document.getElementById('ping-by-type-router').addEventListener('click', (e) => {
        e.preventDefault();
        networkGraph.pingDevices('type', 'router');
    });
    
    document.getElementById('ping-by-type-camera').addEventListener('click', (e) => {
        e.preventDefault();
        networkGraph.pingDevices('type', 'camera');
    });
    
    document.getElementById('ping-by-type-apple').addEventListener('click', (e) => {
        e.preventDefault();
        networkGraph.pingDevices('type', 'apple');
    });
    
    // Theme toggle
    document.getElementById('theme-toggle-btn').addEventListener('click', toggleTheme);
    
    // Fullscreen toggle
    document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
    
    // Zoom controls
    document.getElementById('zoom-in').addEventListener('click', () => {
        if (networkGraph) {
            networkGraph.zoomIn();
        }
    });
    
    document.getElementById('zoom-out').addEventListener('click', () => {
        if (networkGraph) {
            networkGraph.zoomOut();
        }
    });
    
    document.getElementById('zoom-fit').addEventListener('click', () => {
        if (networkGraph) {
            networkGraph.zoomToFit();
        }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
        if (networkGraph) {
            networkGraph.resize();
        }
    });
    
    // ESC key to exit fullscreen
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape' && isFullscreen) {
            toggleFullscreen();
        }
    });
});
</script>
{% endblock %}