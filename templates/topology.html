{% extends "base_beautiful.html" %}

{% block title %}Network Map - HomeNetMon{% endblock %}

{% block navbar %}
<!-- Override standard navigation with topology-specific header -->
<nav class="top-nav">
    <div class="nav-brand">
        <h2>HomeNetMon</h2>
    </div>
    <div class="nav-links">
        <a href="/" class="nav-link">Dashboard</a>
        <a href="/full-view" class="nav-link">Full View</a>
        <a href="/devices" class="nav-link">Devices</a>
        <a href="/network-map" class="nav-link active">Network Map</a>
        <a href="/security" class="nav-link">Security</a>
        <a href="/analytics" class="nav-link">Reports</a>
        <a href="/settings" class="nav-link">Settings</a>
    </div>
</nav>
{% endblock %}

{% block extra_head %}
<!-- D3.js Library for Network Visualization -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
{% endblock %}

{% block extra_css %}
<style>
/* Reset and Modern Foundation */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* CSS Custom Properties for Dark Theme - Topology Specific */
:root {
    /* Modern Color Palette */
    --topology-primary: #7877c6;
    --topology-primary-rgb: 120, 119, 198;
    --topology-secondary: #a0a0ff;
    --topology-accent: #06b6d4;
    --topology-success: #10b981;
    --topology-warning: #f59e0b;
    --topology-danger: #ef4444;
    --topology-info: #3b82f6;

    /* Status Colors */
    --status-online: #10b981;
    --status-online-rgb: 16, 185, 129;
    --status-offline: #ef4444;
    --status-offline-rgb: 239, 68, 68;
    --status-warning: #f59e0b;
    --status-warning-rgb: 245, 158, 11;
    --status-unknown: #6b7280;
    --status-unknown-rgb: 107, 114, 128;

    /* Background Colors for Dark Theme */
    --topology-bg-primary: #0f0f23;
    --topology-bg-secondary: #1a1a2e;
    --topology-bg-tertiary: #16213e;
    --topology-surface: rgba(255, 255, 255, 0.03);
    --topology-surface-elevated: rgba(255, 255, 255, 0.05);

    /* Text Colors for Dark Theme */
    --topology-text-primary: #ffffff;
    --topology-text-secondary: rgba(255, 255, 255, 0.8);
    --topology-text-muted: rgba(255, 255, 255, 0.6);
    --topology-text-inverse: #0f0f23;

    /* Border Colors for Dark Theme */
    --topology-border-light: rgba(255, 255, 255, 0.1);
    --topology-border-medium: rgba(255, 255, 255, 0.2);
    --topology-border-strong: rgba(255, 255, 255, 0.3);

    /* Shadows for Dark Theme */
    --topology-shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
    --topology-shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
    --topology-shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.5);
    --topology-shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.6);

    /* Spacing & Sizing */
    --space-1: 0.25rem;
    --space-2: 0.5rem;
    --space-3: 0.75rem;
    --space-4: 1rem;
    --space-5: 1.25rem;
    --space-6: 1.5rem;
    --space-8: 2rem;
    --space-10: 2.5rem;
    --space-12: 3rem;

    --radius-sm: 0.375rem;
    --radius-md: 0.5rem;
    --radius-lg: 0.75rem;
    --radius-xl: 1rem;
    --radius-2xl: 1.5rem;

    /* Glass Effects */
    --glass-backdrop: blur(20px);
    --glass-border: 1px solid rgba(255, 255, 255, 0.1);

    /* Transitions */
    --transition-fast: 0.15s ease;
    --transition-base: 0.2s ease;
    --transition-slow: 0.3s ease;
}

/* Override body styles for topology mode */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', sans-serif;
    background: #0f0f23;
    color: #ffffff;
    line-height: 1.6;
    overflow-x: hidden;
    min-height: 100vh;
    padding-top: 80px;
}

/* Animated background */
body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at top, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at bottom, rgba(6, 182, 212, 0.05) 0%, transparent 50%);
    pointer-events: none;
    z-index: -1;
}

/* Navigation */
.top-nav {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 70px;
    background: rgba(15, 15, 35, 0.95);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 2rem;
}

.nav-brand h2 {
    font-size: 1.5rem;
    font-weight: 300;
    letter-spacing: -1px;
    background: linear-gradient(135deg, #ffffff 0%, #a0a0ff 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.nav-links {
    display: flex;
    gap: 2rem;
    align-items: center;
}

.nav-link {
    color: rgba(255, 255, 255, 0.7);
    text-decoration: none;
    font-weight: 400;
    font-size: 1rem;
    transition: all 0.3s ease;
    padding: 0.5rem 1rem;
    border-radius: 8px;
}

.nav-link:hover {
    color: #ffffff;
    background: rgba(255, 255, 255, 0.05);
}

.nav-link.active {
    color: #ffffff;
    background: rgba(120, 119, 198, 0.2);
}

/* Main Container */
.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 2rem;
}

.header {
    margin-bottom: 3rem;
}

.page-title {
    font-size: 2.5rem;
    font-weight: 300;
    letter-spacing: -2px;
    background: linear-gradient(135deg, #ffffff 0%, #a0a0ff 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 0.5rem;
}

.page-subtitle {
    color: rgba(255, 255, 255, 0.7);
    font-size: 1.1rem;
    font-weight: 300;
}

/* Stats Grid */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-bottom: 3rem;
}

.stat-card {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 1.5rem;
    text-align: center;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
}

.stat-card:hover {
    transform: translateY(-2px);
    border-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.stat-icon {
    font-size: 2rem;
    margin-bottom: 0.5rem;
}

.stat-value {
    font-size: 2.5rem;
    font-weight: 300;
    margin-bottom: 0.5rem;
    color: #ffffff;
}

.stat-label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Cards */
.modern-card {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 20px;
    backdrop-filter: blur(20px);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
}

.modern-card:hover {
    border-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4);
}

.card-header {
    background: rgba(255, 255, 255, 0.05) !important;
    backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px 16px 0 0 !important;
    color: #ffffff;
    padding: 1.5rem 2rem;
}

.card-body {
    padding: 2rem;
}

/* Buttons */
.btn-modern {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #ffffff;
    padding: 0.5rem 1rem;
    border-radius: 8px;
    font-size: 0.85rem;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
}

.btn-modern:hover {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 255, 255, 0.3);
    color: #ffffff;
    transform: translateY(-1px);
}

.btn-primary-modern {
    background: linear-gradient(135deg, var(--topology-primary) 0%, var(--topology-secondary) 100%);
    border: none;
    color: #ffffff;
}

.btn-primary-modern:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(120, 119, 198, 0.3);
}

/* Dropdowns */
.dropdown-menu {
    background: rgba(15, 15, 35, 0.95);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
}

.dropdown-item {
    color: rgba(255, 255, 255, 0.8);
    transition: all 0.2s ease;
}

.dropdown-item:hover {
    background: rgba(255, 255, 255, 0.1);
    color: #ffffff;
}

/* Topology specific styles */
#network-graph {
    width: 100%;
    height: 600px;
    border-radius: 12px;
    background: rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

/* Filter styles */
.filter-inline {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.filter-inline-label {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
}

.form-check-input:checked {
    background-color: var(--topology-primary);
    border-color: var(--topology-primary);
}

.compact {
    font-size: 0.75rem;
}

/* Device type dropdown */
.device-type-dropdown {
    min-width: 250px;
}

/* Responsive Design */
@media (max-width: 768px) {
    .nav-links {
        gap: 1rem;
    }

    .page-title {
        font-size: 1.8rem;
    }

    .container {
        padding: 1rem;
    }

    .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
    }

    .stat-card {
        padding: 1rem;
    }

    .card-header {
        padding: 1rem;
    }

    .card-body {
        padding: 1rem;
    }
}

@media (max-width: 576px) {
    body {
        padding-top: 60px;
    }

    .top-nav {
        height: 60px;
        padding: 0 1rem;
        flex-direction: column;
        gap: 0.5rem;
        height: auto;
        padding: 1rem;
    }

    .nav-links {
        gap: 0.5rem;
        flex-wrap: wrap;
        justify-content: center;
    }

    .nav-link {
        font-size: 0.9rem;
        padding: 0.25rem 0.5rem;
    }

    .page-title {
        font-size: 1.5rem;
    }

    .stats-grid {
        grid-template-columns: 1fr;
    }

    #network-graph {
        height: 400px;
    }
}

/* Loading and skeleton states */
.loading-skeleton {
    background: linear-gradient(90deg,
        rgba(255, 255, 255, 0.1) 25%,
        rgba(255, 255, 255, 0.2) 50%,
        rgba(255, 255, 255, 0.1) 75%
    );
    background-size: 200% 100%;
    animation: loading-shimmer 1.5s infinite;
}

@keyframes loading-shimmer {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
}

/* Additional topology-specific styles will be preserved from original */
.compact-header {
    padding: var(--space-3) var(--space-4) !important;
}

.compact-header h5 {
    font-size: 1.1rem;
    font-weight: 600;
}

/* Compact Filter Styling */
.filter-section {
    display: flex;
    align-items: center;
    gap: var(--space-3);
    flex-wrap: wrap;
}

.filter-group {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    padding: var(--space-2) var(--space-3);
    background: var(--topology-surface);
    border: var(--glass-border);
    border-radius: var(--radius-md);
    font-size: 0.875rem;
}

.filter-group-label {
    color: var(--topology-text-secondary);
    font-weight: 500;
    min-width: max-content;
}

.card-header h5 {
    color: var(--topology-text-inverse) !important;
    font-weight: 600;
    letter-spacing: 0.025em;
    margin: 0;
}

/* Button Group Styling */
.btn-group-modern {
    display: flex;
    background: var(--topology-surface);
    border: var(--glass-border);
    border-radius: var(--radius-lg);
    padding: var(--space-1);
    gap: var(--space-1);
}

.btn-group-modern .btn {
    background: transparent;
    border: none;
    color: var(--topology-text-secondary);
    padding: var(--space-2) var(--space-3);
    border-radius: var(--radius-md);
    font-size: 0.875rem;
    font-weight: 500;
    transition: all var(--transition-fast);
    white-space: nowrap;
}

.btn-group-modern .btn:hover {
    background: var(--topology-surface-elevated);
    color: var(--topology-text-primary);
}

.btn-group-modern .btn.active {
    background: var(--topology-primary);
    color: var(--topology-text-inverse);
    box-shadow: var(--topology-shadow-sm);
}

/* Form Controls */
.form-control-modern {
    background: var(--topology-surface) !important;
    border: var(--glass-border) !important;
    border-radius: var(--radius-lg) !important;
    color: var(--topology-text-primary) !important;
    padding: var(--space-3) var(--space-4) !important;
    font-size: 0.875rem;
    transition: all var(--transition-fast);
}

.form-control-modern:focus {
    background: var(--topology-surface-elevated) !important;
    border-color: var(--topology-primary) !important;
    box-shadow: 0 0 0 3px rgba(var(--topology-primary-rgb), 0.1) !important;
    color: var(--topology-text-primary) !important;
}

.form-control-modern::placeholder {
    color: var(--topology-text-muted) !important;
}

/* Form Check (Checkboxes & Radio) */
.form-check-input {
    background-color: var(--topology-surface) !important;
    border: 1px solid var(--topology-border-medium) !important;
    border-radius: var(--radius-sm) !important;
    transition: all var(--transition-fast);
}

.form-check-input:checked {
    background-color: var(--topology-primary) !important;
    border-color: var(--topology-primary) !important;
}

.form-check-input:focus {
    box-shadow: 0 0 0 3px rgba(var(--topology-primary-rgb), 0.2) !important;
}

.form-check-label {
    color: var(--topology-text-secondary);
    font-size: 0.875rem;
    transition: color var(--transition-fast);
}

.form-check:hover .form-check-label {
    color: var(--topology-text-primary);
}

/* Select Dropdown */
.form-select {
    background: var(--topology-surface) !important;
    border: var(--glass-border) !important;
    border-radius: var(--radius-lg) !important;
    color: var(--topology-text-primary) !important;
    padding: var(--space-3) var(--space-4) !important;
    font-size: 0.875rem;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m1 6 7 7 7-7'/%3e%3c/svg%3e") !important;
}

.form-select:focus {
    border-color: var(--topology-primary) !important;
    box-shadow: 0 0 0 3px rgba(var(--topology-primary-rgb), 0.1) !important;
}

/* Modal Styling */
.modal-content {
    background: var(--topology-bg-secondary) !important;
    border: var(--glass-border) !important;
    border-radius: var(--radius-2xl) !important;
    backdrop-filter: var(--glass-backdrop);
    box-shadow: var(--topology-shadow-xl);
}

.modal .modal-header {
    background: linear-gradient(135deg, var(--topology-primary) 0%, var(--topology-secondary) 100%);
    color: var(--topology-text-inverse);
    border-bottom: none;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
    padding: var(--space-5) var(--space-6);
}

.modal .modal-header .modal-title {
    font-weight: 600;
    font-size: 1.125rem;
}

.modal .modal-header .btn-close {
    background: rgba(255, 255, 255, 0.2);
    border-radius: var(--radius-md);
    opacity: 1;
    padding: var(--space-2);
    transition: all var(--transition-fast);
}

.modal .modal-header .btn-close:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

.modal .modal-body {
    background: var(--topology-bg-secondary);
    color: var(--topology-text-primary);
    padding: var(--space-6);
    border-radius: 0 0 var(--radius-xl) var(--radius-xl);
}

.modal .modal-footer {
    background: var(--topology-bg-secondary);
    border-top: var(--glass-border);
    padding: var(--space-4) var(--space-6);
    border-radius: 0 0 var(--radius-xl) var(--radius-xl);
}

/* Input Group */
.input-group {
    gap: var(--space-2);
}

.input-group .form-control {
    border-radius: var(--radius-lg) !important;
}

.input-group-text {
    background: var(--topology-surface) !important;
    border: var(--glass-border) !important;
    color: var(--topology-text-secondary) !important;
    border-radius: var(--radius-lg) !important;
}

/* Text Classes */
.text-gradient-primary {
    background: linear-gradient(135deg, var(--topology-primary) 0%, var(--topology-secondary) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.text-gradient-accent {
    background: linear-gradient(135deg, var(--topology-accent) 0%, var(--topology-info) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* Alert Styling */
.alert {
    background: var(--topology-surface-elevated) !important;
    border: var(--glass-border) !important;
    border-radius: var(--radius-lg) !important;
    color: var(--topology-text-primary) !important;
    backdrop-filter: var(--glass-backdrop);
}

.alert-info {
    border-left: 4px solid var(--topology-info) !important;
}

.alert-success {
    border-left: 4px solid var(--topology-success) !important;
}

.alert-warning {
    border-left: 4px solid var(--topology-warning) !important;
}

.alert-danger {
    border-left: 4px solid var(--topology-danger) !important;
}

/* Dropdown Menu Enhanced */
.dropdown-menu {
    background: var(--topology-surface);
    border: var(--topology-border-light);
    border-radius: var(--radius-lg);
    box-shadow: var(--topology-shadow-lg);
    backdrop-filter: var(--glass-backdrop);
    padding: var(--space-2);
}

.dropdown-item {
    color: var(--topology-text-secondary);
    border-radius: var(--radius-md);
    padding: var(--space-2) var(--space-3);
    margin: var(--space-1) 0;
    transition: all var(--transition-fast);
    font-size: 0.875rem;
}

.dropdown-item:hover,
.dropdown-item:focus {
    background: var(--topology-surface-elevated);
    color: var(--topology-text-primary);
}

.dropdown-item.active {
    background: var(--topology-primary);
    color: var(--topology-text-inverse);
}

.dropdown-divider {
    border-color: var(--topology-border-light);
    margin: var(--space-2) 0;
}

/* Badge Styling */
.badge {
    background: var(--topology-surface-elevated) !important;
    color: var(--topology-text-primary) !important;
    border-radius: var(--radius-md) !important;
    padding: var(--space-1) var(--space-2) !important;
    font-size: 0.75rem;
    font-weight: 500;
}

.badge-primary {
    background: var(--topology-primary) !important;
    color: var(--topology-text-inverse) !important;
}

.badge-success {
    background: var(--topology-success) !important;
    color: var(--topology-text-inverse) !important;
}

.badge-warning {
    background: var(--topology-warning) !important;
    color: var(--topology-text-inverse) !important;
}

.badge-danger {
    background: var(--topology-danger) !important;
    color: var(--topology-text-inverse) !important;
}

.badge-info {
    background: var(--topology-info) !important;
    color: var(--topology-text-inverse) !important;
}

/* Progress Bar */
.progress {
    background: var(--topology-surface) !important;
    border-radius: var(--radius-lg) !important;
    height: 0.5rem;
    overflow: hidden;
}

.progress-bar {
    background: linear-gradient(135deg, var(--topology-primary) 0%, var(--topology-secondary) 100%) !important;
    border-radius: var(--radius-lg) !important;
    transition: width var(--transition-base);
}

/* Tooltip Enhancement */
.tooltip {
    font-size: 0.75rem;
}

.tooltip .tooltip-inner {
    background: var(--topology-bg-secondary) !important;
    color: var(--topology-text-primary) !important;
    border: var(--glass-border) !important;
    border-radius: var(--radius-md) !important;
    backdrop-filter: var(--glass-backdrop);
    box-shadow: var(--topology-shadow-md);
    padding: var(--space-2) var(--space-3) !important;
}

/* Scrollbar Styling */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: var(--topology-surface);
    border-radius: var(--radius-md);
}

::-webkit-scrollbar-thumb {
    background: var(--topology-border-medium);
    border-radius: var(--radius-md);
    transition: background var(--transition-fast);
}

::-webkit-scrollbar-thumb:hover {
    background: var(--topology-border-strong);
}

/* Accessibility & Focus States */
*:focus {
    outline: 2px solid var(--topology-primary);
    outline-offset: 2px;
}

.btn:focus {
    box-shadow: 0 0 0 3px rgba(var(--topology-primary-rgb), 0.3);
}

/* Print Styles */
@media print {
    .top-nav,
    .btn,
    .dropdown {
        display: none !important;
    }

    body {
        background: white !important;
        color: black !important;
    }

    .modern-card {
        border: 1px solid #ccc !important;
        background: white !important;
    }
}

/* High Contrast Mode */
@media (prefers-contrast: high) {
    :root {
        --topology-border-light: rgba(255, 255, 255, 0.3);
        --topology-border-medium: rgba(255, 255, 255, 0.5);
        --topology-border-strong: rgba(255, 255, 255, 0.7);
        --topology-text-secondary: rgba(255, 255, 255, 0.9);
        --topology-text-muted: rgba(255, 255, 255, 0.8);
    }
}

/* Reduced Motion */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="container">
    <!-- Header -->
    <div class="header">
        <h1 class="page-title">Network Map</h1>
        <p class="page-subtitle">Interactive visualization of your network topology and device relationships</p>
    </div>

    <!-- Stats Overview -->
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-icon">🖥️</div>
            <div class="stat-value" id="overview-total">-</div>
            <div class="stat-label">Total Devices</div>
        </div>
        <div class="stat-card">
            <div class="stat-icon">✅</div>
            <div class="stat-value text-success" id="overview-up">-</div>
            <div class="stat-label">Online</div>
        </div>
        <div class="stat-card">
            <div class="stat-icon">❌</div>
            <div class="stat-value text-danger" id="overview-down">-</div>
            <div class="stat-label">Offline</div>
        </div>
        <div class="stat-card">
            <div class="stat-icon">⚠️</div>
            <div class="stat-value text-warning" id="overview-alerts">-</div>
            <div class="stat-label">Alerts</div>
        </div>
    </div>

    <!-- Interactive Network Graph -->
    <div class="modern-card mb-4" id="topology-card">
        <div class="card-header compact-header">
            <!-- Single Row: Title, Filters, and Actions -->
            <div class="d-flex align-items-center justify-content-between flex-wrap gap-3">
                <!-- Left: Title -->
                <h5 class="mb-0 d-flex align-items-center" style="color: #ffffff;">
                    🗺️ <span style="margin-left: 0.5rem;">Network Topology</span>
                </h5>

                <!-- Center: Compact Filter Controls -->
                <div class="d-flex align-items-center gap-3 flex-wrap">
                    <!-- Status Filters - Inline -->
                    <div class="filter-inline">
                        <span class="filter-inline-label">Status:</span>
                        <div class="d-flex gap-2">
                            <div class="form-check form-check-inline mb-0">
                                <input class="form-check-input" type="checkbox" id="status-online" checked>
                                <label class="form-check-label compact" for="status-online">
                                    <i class="bi bi-check-circle-fill text-success"></i>
                                </label>
                            </div>
                            <div class="form-check form-check-inline mb-0">
                                <input class="form-check-input" type="checkbox" id="status-offline" checked>
                                <label class="form-check-label compact" for="status-offline">
                                    <i class="bi bi-x-circle-fill text-danger"></i>
                                </label>
                            </div>
                            <div class="form-check form-check-inline mb-0">
                                <input class="form-check-input" type="checkbox" id="status-warning" checked>
                                <label class="form-check-label compact" for="status-warning">
                                    <i class="bi bi-exclamation-triangle-fill text-warning"></i>
                                </label>
                            </div>
                            <div class="form-check form-check-inline mb-0">
                                <input class="form-check-input" type="checkbox" id="status-unknown" checked>
                                <label class="form-check-label compact" for="status-unknown">
                                    <i class="bi bi-question-circle-fill" style="color: var(--status-unknown);"></i>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Device Type Dropdown -->
                    <div class="dropdown">
                        <button class="btn-modern dropdown-toggle" type="button" data-bs-toggle="dropdown" title="Filter Device Types">
                            🔽 Types
                        </button>
                        <div class="dropdown-menu p-3 device-type-dropdown">
                            <div class="row g-2">
                                <div class="col-6">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="type-router" checked>
                                        <label class="form-check-label small" for="type-router">
                                            🛜 Router
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="type-switch" checked>
                                        <label class="form-check-label small" for="type-switch">
                                            🔀 Switch
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="type-computer" checked>
                                        <label class="form-check-label small" for="type-computer">
                                            💻 Computer
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="type-laptop" checked>
                                        <label class="form-check-label small" for="type-laptop">
                                            📱 Mobile
                                        </label>
                                    </div>
                                </div>
                                <div class="col-6">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="type-server" checked>
                                        <label class="form-check-label small" for="type-server">
                                            🖥️ Server
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="type-printer" checked>
                                        <label class="form-check-label small" for="type-printer">
                                            🖨️ Printer
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="type-camera" checked>
                                        <label class="form-check-label small" for="type-camera">
                                            📹 Camera
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="type-unknown" checked>
                                        <label class="form-check-label small" for="type-unknown">
                                            ❓ Other
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right: Action Buttons -->
                <div class="d-flex align-items-center gap-2">
                    <!-- Layout Dropdown -->
                    <div class="dropdown">
                        <button class="btn-modern dropdown-toggle" type="button" data-bs-toggle="dropdown" title="Change Layout">
                            📐 Layout
                        </button>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="#" data-layout="force">
                                <i class="bi bi-diagram-2 me-2"></i>Force-Directed
                            </a></li>
                            <li><a class="dropdown-item" href="#" data-layout="circular">
                                <i class="bi bi-circle me-2"></i>Circular
                            </a></li>
                            <li><a class="dropdown-item" href="#" data-layout="hierarchical">
                                <i class="bi bi-diagram-3 me-2"></i>Hierarchical
                            </a></li>
                            <li><a class="dropdown-item" href="#" data-layout="grid">
                                <i class="bi bi-grid me-2"></i>Grid
                            </a></li>
                        </ul>
                    </div>

                    <!-- Ping Dropdown -->
                    <div class="dropdown">
                        <button class="btn-modern dropdown-toggle" type="button" data-bs-toggle="dropdown" title="Ping Devices">
                            📡 Ping
                        </button>
                        <ul class="dropdown-menu dropdown-menu-end">
                            <li><a class="dropdown-item" href="#" id="ping-all-devices">
                                <i class="bi bi-broadcast me-2"></i>All Devices
                            </a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="#" id="ping-by-type-router">
                                <i class="bi bi-router me-2"></i>Routers
                            </a></li>
                            <li><a class="dropdown-item" href="#" id="ping-by-type-computer">
                                <i class="bi bi-pc-display me-2"></i>Computers
                            </a></li>
                            <li><a class="dropdown-item" href="#" id="ping-by-type-mobile">
                                <i class="bi bi-phone me-2"></i>Mobile Devices
                            </a></li>
                        </ul>
                    </div>

                    <!-- Additional Actions -->
                    <button class="btn-modern" id="refresh-topology" title="Refresh Network Data">
                        <i class="bi bi-arrow-clockwise"></i>
                    </button>
                    <button class="btn-modern" id="fullscreen-toggle" title="Toggle Fullscreen">
                        <i class="bi bi-fullscreen"></i>
                    </button>
                    <button class="btn-modern" id="zoom-fit" title="Zoom to Fit">
                        <i class="bi bi-arrows-angle-contract"></i>
                    </button>
                </div>
            </div>
        </div>

        <div class="card-body">
            <!-- Network Graph Container -->
            <div id="network-graph"></div>

            <!-- Loading Indicator -->
            <div id="loading-indicator" class="text-center py-5" style="display: none;">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading network data...</span>
                </div>
                <p class="mt-3 text-muted">Loading network topology...</p>
            </div>

            <!-- Error State -->
            <div id="error-state" class="text-center py-5" style="display: none;">
                <div class="alert alert-danger" role="alert">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    <strong>Error loading network data</strong>
                    <p class="mb-0 mt-2">Please check your connection and try again.</p>
                </div>
                <button class="btn btn-primary-modern mt-3" id="retry-load">
                    <i class="bi bi-arrow-clockwise me-2"></i>Retry
                </button>
            </div>
        </div>
    </div>

    <!-- Additional Information Cards -->
    <div class="row">
        <div class="col-lg-6">
            <div class="modern-card">
                <div class="card-header">
                    <h5><i class="bi bi-info-circle me-2"></i>Legend</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-6">
                            <h6>Device Status</h6>
                            <ul class="list-unstyled">
                                <li><i class="bi bi-circle-fill text-success me-2"></i>Online</li>
                                <li><i class="bi bi-circle-fill text-danger me-2"></i>Offline</li>
                                <li><i class="bi bi-circle-fill text-warning me-2"></i>Warning</li>
                                <li><i class="bi bi-circle-fill text-secondary me-2"></i>Unknown</li>
                            </ul>
                        </div>
                        <div class="col-6">
                            <h6>Connections</h6>
                            <ul class="list-unstyled">
                                <li><span class="me-2">━━━</span>Direct Link</li>
                                <li><span class="me-2">┅┅┅</span>Wireless</li>
                                <li><span class="me-2">═══</span>High Traffic</li>
                                <li><span class="me-2">───</span>Low Traffic</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-lg-6">
            <div class="modern-card">
                <div class="card-header">
                    <h5><i class="bi bi-keyboard me-2"></i>Controls</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-6">
                            <h6>Mouse</h6>
                            <ul class="list-unstyled small">
                                <li><strong>Click:</strong> Select device</li>
                                <li><strong>Drag:</strong> Move device</li>
                                <li><strong>Wheel:</strong> Zoom in/out</li>
                                <li><strong>Double-click:</strong> Device details</li>
                            </ul>
                        </div>
                        <div class="col-6">
                            <h6>Keyboard</h6>
                            <ul class="list-unstyled small">
                                <li><strong>Arrow keys:</strong> Navigate</li>
                                <li><strong>Enter:</strong> Select device</li>
                                <li><strong>+/-:</strong> Zoom in/out</li>
                                <li><strong>F11:</strong> Fullscreen</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Ping Progress Modal -->
<div class="modal fade" id="pingProgressModal" tabindex="-1" aria-labelledby="pingProgressModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h6 class="modal-title" id="pingProgressModalLabel">
                    <i class="bi bi-broadcast me-2"></i>
                    <span id="ping-operation-title" class="text-gradient-primary">Testing Network Connectivity</span>
                </h6>
                <button type="button" class="btn-close" id="ping-cancel-btn" aria-label="Cancel"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span class="small text-muted">Progress</span>
                        <span class="small text-muted" id="ping-progress-text">0 / 0</span>
                    </div>
                    <div class="progress" style="height: 8px;">
                        <div class="progress-bar" role="progressbar" id="ping-progress-bar" style="width: 0%"></div>
                    </div>
                </div>

                <div id="ping-results" class="ping-results-container">
                    <!-- Results will be populated here -->
                </div>

                <div id="ping-summary" class="mt-3" style="display: none;">
                    <div class="alert alert-info">
                        <div class="d-flex justify-content-between">
                            <span><strong>Summary:</strong></span>
                            <span id="ping-summary-text"></span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary-modern" id="ping-export-results" style="display: none;">
                    <i class="bi bi-download me-2"></i>Export Results
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Device Tooltip -->
<div id="device-tooltip" class="position-absolute" style="display: none; z-index: 1050; pointer-events: none;">
    <div class="card border-0 shadow-lg" style="max-width: 300px; background: rgba(26, 26, 46, 0.95); backdrop-filter: blur(20px);">
        <div class="card-body p-3">
            <div class="d-flex align-items-start">
                <div class="card-header border-0 bg-transparent p-0">
                    <div class="d-flex align-items-center p-3 pb-2">
                        <div class="device-icon-container me-3 p-2 rounded-circle d-flex align-items-center justify-content-center"
                             style="background: rgba(var(--topology-primary-rgb), 0.1); width: 40px; height: 40px;">
                            <span id="tooltip-icon" style="font-size: 1.2em; color: var(--topology-primary);">❓</span>
                        </div>
                        <div class="flex-grow-1">
                            <h6 class="mb-1 text-white" id="tooltip-name">Device Name</h6>
                            <small class="text-muted d-block" id="tooltip-ip">192.168.1.1</small>
                        </div>
                        <div class="ms-2">
                            <span class="badge rounded-pill" id="tooltip-status">Unknown</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="row g-2 text-center mt-2">
                <div class="col-4">
                    <div class="small text-muted">Type</div>
                    <div class="fw-medium text-white" id="tooltip-type">-</div>
                </div>
                <div class="col-4">
                    <div class="small text-muted">Response</div>
                    <div class="fw-medium text-white" id="tooltip-response">-</div>
                </div>
                <div class="col-4">
                    <div class="small text-muted">Uptime</div>
                    <div class="fw-medium text-white" id="tooltip-uptime">-</div>
                </div>
            </div>

            <div class="mt-2 pt-2 border-top border-secondary">
                <div class="d-flex justify-content-between">
                    <small class="text-muted">Last Seen</small>
                    <small class="text-white" id="tooltip-last-seen">-</small>
                </div>
                <div class="d-flex justify-content-between mt-1">
                    <small class="text-muted">MAC Address</small>
                    <small class="text-white" id="tooltip-mac">-</small>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- D3.js for network graph -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<!-- Socket.IO -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

<script>
// Network Topology Application
class NetworkTopology {
    constructor(containerId) {
        this.containerId = containerId;
        this.container = d3.select(`#${containerId}`);
        this.width = 0;
        this.height = 600;
        this.nodes = [];
        this.links = [];
        this.allNodesData = [];
        this.allLinksData = [];
        this.selectedLayout = 'force';
        this.isFullscreen = false;
        this.retryCount = 0;
        this.maxRetries = 3;
        this.retryDelay = 2000;

        // Initialize keyboard shortcuts for topology navigation
        this.selectedNodeIndex = -1;
        this.isKeyboardNavigationActive = false;

        document.addEventListener('keydown', (event) => {
            this.handleKeyboardShortcut(event);
        });

        this.initializeGraph();
        this.setupEventListeners();
        this.loadData();
    }

    handleKeyboardShortcut(event) {
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
            return; // Don't interfere with form inputs
        }

        const key = event.key.toLowerCase();

        switch(key) {
            case 'f11':
                event.preventDefault();
                this.toggleFullscreen();
                break;

            case 'escape':
                if (this.isKeyboardNavigationActive) {
                    event.preventDefault();
                    this.clearNodeSelection();
                }
                break;

            case '1':
            case '2':
            case '3':
            case '4':
                event.preventDefault();
                const layouts = ['force', 'circular', 'hierarchical', 'grid'];
                this.setLayout(layouts[parseInt(key) - 1]);
                break;

            case '+':
            case '=':
                event.preventDefault();
                this.zoom(1.2);
                break;

            case '-':
                event.preventDefault();
                this.zoom(0.8);
                break;

            case '0':
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    this.zoomToFit();
                }
                break;

            case 'r':
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    this.refreshData();
                }
                break;

            case 'arrowup':
            case 'arrowdown':
            case 'arrowleft':
            case 'arrowright':
                event.preventDefault();
                this.navigateNodes(key);
                break;

            case 'enter':
                if (this.selectedNodeIndex >= 0) {
                    event.preventDefault();
                    this.showDeviceDetails(this.nodes[this.selectedNodeIndex]);
                }
                break;

            case '?':
                if (event.shiftKey) {
                    event.preventDefault();
                    this.showKeyboardShortcuts();
                }
                break;
        }
    }

    navigateNodes(direction) {
        if (this.nodes.length === 0) return;

        this.isKeyboardNavigationActive = true;

        // Get current node position if one is selected
        let currentNode = this.selectedNodeIndex >= 0 ? this.nodes[this.selectedNodeIndex] : null;
        let newIndex = this.selectedNodeIndex;

        if (direction === 'arrowup' || direction === 'arrowdown') {
            // Navigate vertically
            if (currentNode) {
                let closestNode = null;
                let closestDistance = Infinity;

                this.nodes.forEach((node, index) => {
                    if (index === this.selectedNodeIndex) return;

                    const isCorrectDirection = direction === 'arrowup' ?
                        node.y < currentNode.y : node.y > currentNode.y;

                    if (isCorrectDirection) {
                        const distance = Math.abs(node.y - currentNode.y) +
                                        Math.abs(node.x - currentNode.x) * 0.5; // Weight horizontal distance less
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestNode = node;
                            newIndex = index;
                        }
                    }
                });
            } else {
                // No node selected, select the topmost or bottommost
                newIndex = direction === 'arrowup' ?
                    this.nodes.findIndex(n => n.y === Math.min(...this.nodes.map(node => node.y))) :
                    this.nodes.findIndex(n => n.y === Math.max(...this.nodes.map(node => node.y)));
            }
        } else {
            // Navigate horizontally
            if (currentNode) {
                let closestNode = null;
                let closestDistance = Infinity;

                this.nodes.forEach((node, index) => {
                    if (index === this.selectedNodeIndex) return;

                    const isCorrectDirection = direction === 'arrowleft' ?
                        node.x < currentNode.x : node.x > currentNode.x;

                    if (isCorrectDirection) {
                        const distance = Math.abs(node.x - currentNode.x) +
                                        Math.abs(node.y - currentNode.y) * 0.5; // Weight vertical distance less
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestNode = node;
                            newIndex = index;
                        }
                    }
                });
            } else {
                // No node selected, select the leftmost or rightmost
                newIndex = direction === 'arrowleft' ?
                    this.nodes.findIndex(n => n.x === Math.min(...this.nodes.map(node => node.x))) :
                    this.nodes.findIndex(n => n.x === Math.max(...this.nodes.map(node => node.x)));
            }
        }

        if (newIndex >= 0 && newIndex !== this.selectedNodeIndex) {
            this.selectNode(newIndex);
        } else if (this.selectedNodeIndex < 0 && this.nodes.length > 0) {
            // No valid navigation found, select first node
            this.selectNode(0);
        }
    }

    selectNode(index) {
        this.clearNodeSelection();

        if (index >= 0 && index < this.nodes.length) {
            this.selectedNodeIndex = index;
            const selectedNode = this.nodes[index];

            // Highlight the selected node
            this.nodeGroup.selectAll('circle')
                .filter((d, i) => i === index)
                .attr('stroke', '#00ff00')
                .attr('stroke-width', 3);

            // Show keyboard navigation indicator
            this.showNavigationIndicator(selectedNode);
        }
    }

    clearNodeSelection() {
        this.selectedNodeIndex = -1;
        this.isKeyboardNavigationActive = false;

        // Remove highlighting
        this.nodeGroup.selectAll('circle')
            .attr('stroke', d => this.getNodeBorderColor(d))
            .attr('stroke-width', 2);

        // Remove navigation indicator
        this.hideNavigationIndicator();
    }

    showNavigationIndicator(node) {
        this.hideNavigationIndicator();

        // Add pulsing ring around selected node
        this.svg.append('circle')
            .attr('class', 'navigation-indicator')
            .attr('cx', node.x)
            .attr('cy', node.y)
            .attr('r', 25)
            .attr('fill', 'none')
            .attr('stroke', '#00ff00')
            .attr('stroke-width', 2)
            .attr('opacity', 0)
            .transition()
            .duration(500)
            .attr('opacity', 0.8)
            .transition()
            .duration(500)
            .attr('opacity', 0.3)
            .transition()
            .duration(500)
            .attr('opacity', 0.8);
    }

    hideNavigationIndicator() {
        this.nodeGroup.selectAll('.navigation-indicator').remove();
    }

    ensureSelectedNodeVisible() {
        if (this.selectedNodeIndex < 0 || this.selectedNodeIndex >= this.nodes.length) return;

        const selectedNode = this.nodes[this.selectedNodeIndex];
        const transform = d3.zoomTransform(this.svg.node());

        // Check if node is visible in current viewport
        const nodeScreenX = transform.applyX(selectedNode.x);
        const nodeScreenY = transform.applyY(selectedNode.y);

        const margin = 50;
        if (nodeScreenX < margin || nodeScreenX > this.width - margin ||
            nodeScreenY < margin || nodeScreenY > this.height - margin) {

            // Pan to center the selected node
            const centerX = this.width / 2;
            const centerY = this.height / 2;

            const newTransform = d3.zoomIdentity
                .translate(centerX - selectedNode.x * transform.k, centerY - selectedNode.y * transform.k)
                .scale(transform.k);

            this.svg.transition()
                .duration(750)
                .call(this.zoomBehavior.transform, newTransform);
        }
    }

    showKeyboardShortcuts() {
        const shortcuts = {
            'Navigation': [
                { key: 'Arrow Keys', desc: 'Navigate between devices' },
                { key: 'Enter', desc: 'Open device details' },
                { key: 'Esc', desc: 'Exit navigation mode' }
            ],
            'View': [
                { key: '+ / -', desc: 'Zoom in/out' },
                { key: 'Ctrl+0', desc: 'Zoom to fit all' },
                { key: '1-4', desc: 'Switch layouts' },
                { key: 'F11', desc: 'Toggle fullscreen' }
            ],
            'Actions': [
                { key: 'Ctrl+R', desc: 'Refresh data' },
                { key: 'Shift+?', desc: 'Show this help' }
            ]
        };

        let shortcutsHtml = '';
        Object.entries(shortcuts).forEach(([category, items]) => {
            shortcutsHtml += `
                <div class="mb-4">
                    <h6 class="text-gradient-primary">${category}</h6>
                    <div class="row">
                        ${items.map(item => `
                            <div class="col-12 mb-2">
                                <div class="d-flex justify-content-between">
                                    <kbd class="small">${item.key}</kbd>
                                    <span class="small">${item.desc}</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        });

        // Show modal with shortcuts
        const modalHtml = `
            <div class="modal fade" id="shortcutsModal" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title text-gradient-primary">Keyboard Shortcuts</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body" id="shortcuts-content">${shortcutsHtml}</div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Remove existing modal if any
        d3.select('#shortcutsModal').remove();

        // Add modal to body
        d3.select('body').append('div').html(modalHtml);

        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('shortcutsModal'));
        modal.show();

        // Clean up when modal is hidden
        document.getElementById('shortcutsModal').addEventListener('hidden.bs.modal', () => {
            d3.select('#shortcutsModal').remove();
        });
    }

    initializeGraph() {
        // Clear any existing content
        this.container.selectAll("*").remove();

        // Get container dimensions
        const containerRect = document.getElementById(this.containerId).getBoundingClientRect();
        this.width = containerRect.width || 800;
        this.height = 600;

        // Create SVG
        this.svg = this.container.append("svg")
            .attr("width", this.width)
            .attr("height", this.height)
            .style("background", "rgba(0, 0, 0, 0.1)")
            .style("border-radius", "12px");

        // Create zoom behavior
        this.zoomBehavior = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                this.graphGroup.attr("transform", event.transform);
            });

        this.svg.call(this.zoomBehavior);

        // Create main group for graph elements
        this.graphGroup = this.svg.append("g");

        // Create groups for different elements (order matters for layering)
        this.linkGroup = this.graphGroup.append("g").attr("class", "links");
        this.nodeGroup = this.graphGroup.append("g").attr("class", "nodes");
        this.labelGroup = this.graphGroup.append("g").attr("class", "labels");

        // Initialize tooltip
        this.tooltip = d3.select("#device-tooltip");

        console.log("Network graph initialized", {
            width: this.width,
            height: this.height,
            containerId: this.containerId
        });
    }

    setupEventListeners() {
        // Layout buttons
        d3.selectAll('[data-layout]').on('click', (event) => {
            event.preventDefault();
            const layout = event.target.getAttribute('data-layout');
            this.setLayout(layout);
        });

        // Control buttons
        d3.select('#refresh-topology').on('click', () => this.refreshData());
        d3.select('#fullscreen-toggle').on('click', () => this.toggleFullscreen());
        d3.select('#zoom-fit').on('click', () => this.zoomToFit());
        d3.select('#retry-load').on('click', () => this.loadData());

        // Filter checkboxes
        d3.selectAll('#status-online, #status-offline, #status-warning, #status-unknown').on('change', () => {
            this.applyFilters();
        });

        d3.selectAll('[id^="type-"]').on('change', () => {
            this.applyFilters();
        });

        // Ping actions
        d3.select('#ping-all-devices').on('click', (event) => {
            event.preventDefault();
            this.pingDevices('all');
        });

        // Window resize
        window.addEventListener('resize', () => {
            this.resize();
        });
    }

    async loadData() {
        this.showLoading(true);
        this.hideError();

        try {
            console.log("Loading topology data...");

            const response = await fetch('/api/monitoring/topology-test');

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            console.log("Topology data loaded:", data);

            this.processData(data);
            this.updateStats(data);
            this.renderGraph();
            this.retryCount = 0; // Reset retry count on success

        } catch (error) {
            console.error("Error loading topology data:", error);

            if (this.retryCount < this.maxRetries) {
                this.retryCount++;
                console.log(`Retrying... (${this.retryCount}/${this.maxRetries})`);
                setTimeout(() => this.loadData(), this.retryDelay);
            } else {
                this.showError(error.message);
                this.showDiagnostics(error);
            }
        } finally {
            this.showLoading(false);
        }
    }

    showDiagnostics(error) {
        const diagnosticsInfo = {
            'Error Message': error.message || 'Unknown error',
            'Error Type': error.constructor.name,
            'Timestamp': new Date().toISOString(),
            'Browser': navigator.userAgent,
            'D3.js Version': typeof d3 !== 'undefined' ? d3.version || 'Available' : 'Not loaded',
            'Container ID': this.containerId,
            'Container Exists': document.getElementById(this.containerId) ? 'Yes' : 'No',
            'API Endpoint': '/api/monitoring/topology-test',
            'Retry Count': this.retryCount || 0,
            'Max Retries': this.maxRetries,
            'Network Status': navigator.onLine ? 'Online' : 'Offline'
        };

        let diagnosticsHtml = '<div class="small text-muted">';
        Object.entries(diagnosticsInfo).forEach(([key, value]) => {
            diagnosticsHtml += `
                <div class="d-flex justify-content-between mb-1">
                    <span><strong>${key}:</strong></span>
                    <span class="ms-3">${value}</span>
                </div>
            `;
        });
        diagnosticsHtml += '</div>';

        // Show modal with diagnostics
        const modalHtml = `
            <div class="modal fade" id="diagnosticsModal" tabindex="-1">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title text-gradient-primary">Network Map Diagnostics</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body" id="diagnostics-content">${diagnosticsHtml}</div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            <button type="button" class="btn btn-primary-modern" onclick="navigator.clipboard.writeText(document.getElementById('diagnostics-content').innerText)">
                                <i class="bi bi-clipboard me-2"></i>Copy to Clipboard
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Remove existing modal if any
        d3.select('#diagnosticsModal').remove();

        // Add modal to body
        d3.select('body').append('div').html(modalHtml);

        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('diagnosticsModal'));
        modal.show();

        // Clean up when modal is hidden
        document.getElementById('diagnosticsModal').addEventListener('hidden.bs.modal', () => {
            d3.select('#diagnosticsModal').remove();
        });
    }

    processData(data) {
        // Store original data - fix field names to match API response
        this.allNodesData = data.nodes || [];
        this.allLinksData = data.edges || [];

        // Process nodes - map fields to match topology API response
        this.nodes = this.allNodesData.map(node => ({
            id: node.id,
            name: node.label || node.ip,
            ip: node.ip,
            type: node.device_type || 'unknown',
            status: node.status || 'unknown',
            response_time: node.response_time,
            last_seen: node.last_seen,
            uptime: node.uptime_percentage,
            alerts_count: node.active_alerts || 0,
            color: node.color,
            size: node.size || 10,
            icon: node.icon,
            x: Math.random() * this.width,
            y: Math.random() * this.height
        }));

        // Process links - edges structure from topology API
        this.links = this.allLinksData.map(edge => ({
            source: edge.source,
            target: edge.target,
            strength: edge.strength || 1,
            color: edge.color || '#999'
        }));

        console.log(`Processed ${this.nodes.length} nodes and ${this.links.length} links`);
    }

    updateStats(data) {
        const total = this.nodes.length;
        const online = this.nodes.filter(n => n.status === 'online').length;
        const offline = this.nodes.filter(n => n.status === 'offline').length;
        const alerts = this.nodes.reduce((sum, n) => sum + (n.alerts_count || 0), 0);

        d3.select('#overview-total').text(total);
        d3.select('#overview-up').text(online);
        d3.select('#overview-down').text(offline);
        d3.select('#overview-alerts').text(alerts);
    }

    renderGraph() {
        // Clear existing elements
        this.linkGroup.selectAll("*").remove();
        this.nodeGroup.selectAll("*").remove();
        this.labelGroup.selectAll("*").remove();

        if (this.nodes.length === 0) {
            this.showEmptyState();
            return;
        }

        // Create force simulation based on selected layout
        this.createLayout();

        // Render links
        this.renderLinks();

        // Render nodes
        this.renderNodes();

        // Render labels
        this.renderLabels();

        // Start simulation
        if (this.simulation) {
            this.simulation.nodes(this.nodes);

            if (this.simulation.force("link")) {
                this.simulation.force("link").links(this.links);
            }

            this.simulation.alpha(1).restart();
        }
    }

    createLayout() {
        switch (this.selectedLayout) {
            case 'force':
                this.createForceLayout();
                break;
            case 'circular':
                this.createCircularLayout();
                break;
            case 'hierarchical':
                this.createHierarchicalLayout();
                break;
            case 'grid':
                this.createGridLayout();
                break;
            default:
                this.createForceLayout();
        }
    }

    createForceLayout() {
        this.simulation = d3.forceSimulation(this.nodes)
            .force("link", d3.forceLink(this.links).id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(this.width / 2, this.height / 2))
            .force("collision", d3.forceCollide().radius(30))
            .on("tick", () => this.updatePositions());
    }

    createCircularLayout() {
        const radius = Math.min(this.width, this.height) / 3;
        const centerX = this.width / 2;
        const centerY = this.height / 2;

        this.nodes.forEach((node, i) => {
            const angle = (i / this.nodes.length) * 2 * Math.PI;
            node.x = centerX + radius * Math.cos(angle);
            node.y = centerY + radius * Math.sin(angle);
            node.fx = node.x; // Fix positions
            node.fy = node.y;
        });

        this.simulation = d3.forceSimulation(this.nodes)
            .force("link", d3.forceLink(this.links).id(d => d.id))
            .on("tick", () => this.updatePositions());
    }

    createHierarchicalLayout() {
        // Group nodes by type for hierarchical layout
        const typeGroups = {};
        this.nodes.forEach(node => {
            if (!typeGroups[node.type]) {
                typeGroups[node.type] = [];
            }
            typeGroups[node.type].push(node);
        });

        const types = Object.keys(typeGroups);
        const levelHeight = this.height / (types.length + 1);

        types.forEach((type, typeIndex) => {
            const nodes = typeGroups[type];
            const levelY = levelHeight * (typeIndex + 1);

            nodes.forEach((node, nodeIndex) => {
                node.x = (this.width / (nodes.length + 1)) * (nodeIndex + 1);
                node.y = levelY;
                node.fx = node.x;
                node.fy = node.y;
            });
        });

        this.simulation = d3.forceSimulation(this.nodes)
            .force("link", d3.forceLink(this.links).id(d => d.id))
            .on("tick", () => this.updatePositions());
    }

    createGridLayout() {
        const cols = Math.ceil(Math.sqrt(this.nodes.length));
        const cellWidth = this.width / cols;
        const cellHeight = this.height / Math.ceil(this.nodes.length / cols);

        this.nodes.forEach((node, i) => {
            const row = Math.floor(i / cols);
            const col = i % cols;
            node.x = (col + 0.5) * cellWidth;
            node.y = (row + 0.5) * cellHeight;
            node.fx = node.x;
            node.fy = node.y;
        });

        this.simulation = d3.forceSimulation(this.nodes)
            .force("link", d3.forceLink(this.links).id(d => d.id))
            .on("tick", () => this.updatePositions());
    }

    renderLinks() {
        const links = this.linkGroup.selectAll("line")
            .data(this.links)
            .enter().append("line")
            .attr("stroke", "#666")
            .attr("stroke-width", d => Math.sqrt(d.strength || 1))
            .attr("stroke-opacity", 0.6)
            .attr("stroke-dasharray", d => d.type === 'wireless' ? "5,5" : null);
    }

    renderNodes() {
        const nodes = this.nodeGroup.selectAll("circle")
            .data(this.nodes)
            .enter().append("circle")
            .attr("r", d => this.getNodeRadius(d))
            .attr("fill", d => this.getNodeColor(d))
            .attr("stroke", d => this.getNodeBorderColor(d))
            .attr("stroke-width", 2)
            .style("cursor", "pointer")
            .call(this.createDragBehavior())
            .on("click", (event, d) => this.handleNodeClick(event, d))
            .on("dblclick", (event, d) => this.showDeviceDetails(d))
            .on("mouseover", (event, d) => this.showTooltip(event, d))
            .on("mouseout", () => this.hideTooltip());
    }

    renderLabels() {
        const labels = this.labelGroup.selectAll("text")
            .data(this.nodes)
            .enter().append("text")
            .text(d => d.name)
            .attr("font-size", "12px")
            .attr("font-family", "Arial, sans-serif")
            .attr("fill", "#ffffff")
            .attr("text-anchor", "middle")
            .attr("dy", ".35em")
            .style("pointer-events", "none")
            .style("user-select", "none");
    }

    updatePositions() {
        this.linkGroup.selectAll("line")
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        this.nodeGroup.selectAll("circle")
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);

        this.labelGroup.selectAll("text")
            .attr("x", d => d.x)
            .attr("y", d => d.y + 25); // Position labels below nodes
    }

    getNodeRadius(node) {
        const baseRadius = 8;
        const alertMultiplier = node.alerts_count > 0 ? 1.5 : 1;
        return baseRadius * alertMultiplier;
    }

    getNodeColor(node) {
        // First priority: Use API-provided color (already correct Bootstrap colors)
        if (node.color) {
            return node.color;
        }

        // Fallback: Map API status values to colors
        switch (node.status) {
            case 'up':
            case 'online':
                return '#28a745'; // Bootstrap green
            case 'down':
            case 'offline':
                return '#dc3545'; // Bootstrap red
            case 'warning':
            case 'scanning':
            case 'unknown':
                return '#ffc107'; // Bootstrap yellow
            default:
                return '#6c757d'; // Bootstrap gray
        }
    }

    getNodeBorderColor(node) {
        return node.alerts_count > 0 ? '#ffffff' : 'none';
    }

    createDragBehavior() {
        return d3.drag()
            .on("start", (event, d) => {
                if (!event.active && this.simulation) {
                    this.simulation.alphaTarget(0.3).restart();
                }
                d.fx = d.x;
                d.fy = d.y;
            })
            .on("drag", (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on("end", (event, d) => {
                if (!event.active && this.simulation) {
                    this.simulation.alphaTarget(0);
                }
                if (this.selectedLayout === 'force') {
                    d.fx = null;
                    d.fy = null;
                }
            });
    }

    handleNodeClick(event, node) {
        // Find and select this node
        const nodeIndex = this.nodes.findIndex(n => n.id === node.id);
        if (nodeIndex >= 0) {
            this.selectNode(nodeIndex);
            this.ensureSelectedNodeVisible();
        }
    }

    showDeviceDetails(node) {
        // Create device details modal
        const modalHtml = `
            <div class="modal fade" id="deviceDetailsModal" tabindex="-1">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title text-gradient-primary">
                                <i class="bi bi-hdd me-2"></i>${node.name}
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="row">
                                <div class="col-md-6">
                                    <h6>Device Information</h6>
                                    <table class="table table-sm">
                                        <tr><td><strong>Name:</strong></td><td>${node.name}</td></tr>
                                        <tr><td><strong>IP Address:</strong></td><td>${node.ip}</td></tr>
                                        <tr><td><strong>MAC Address:</strong></td><td>${node.mac || 'Unknown'}</td></tr>
                                        <tr><td><strong>Type:</strong></td><td>${node.type}</td></tr>
                                        <tr><td><strong>Vendor:</strong></td><td>${node.vendor || 'Unknown'}</td></tr>
                                        <tr><td><strong>Status:</strong></td><td>
                                            <span class="badge" style="background-color: ${this.getNodeColor(node)}">${node.status}</span>
                                        </td></tr>
                                    </table>
                                </div>
                                <div class="col-md-6">
                                    <h6>Performance Metrics</h6>
                                    <table class="table table-sm">
                                        <tr><td><strong>Response Time:</strong></td><td>${node.response_time ? `${node.response_time.toFixed(1)}ms` : 'N/A'}</td></tr>
                                        <tr><td><strong>Uptime:</strong></td><td>${node.uptime ? `${node.uptime.toFixed(1)}%` : 'N/A'}</td></tr>
                                        <tr><td><strong>Last Seen:</strong></td><td>${node.last_seen ? new Date(node.last_seen).toLocaleString() : 'Unknown'}</td></tr>
                                        <tr><td><strong>Active Alerts:</strong></td><td>${node.alerts_count || 0}</td></tr>
                                    </table>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            <button type="button" class="btn btn-primary-modern" onclick="window.open('/device/${node.id}', '_blank')">
                                <i class="bi bi-box-arrow-up-right me-2"></i>Full Details
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Remove existing modal if any
        d3.select('#deviceDetailsModal').remove();

        // Add modal to body
        d3.select('body').append('div').html(modalHtml);

        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('deviceDetailsModal'));
        modal.show();

        // Clean up when modal is hidden
        document.getElementById('deviceDetailsModal').addEventListener('hidden.bs.modal', () => {
            d3.select('#deviceDetailsModal').remove();
        });
    }

    showTooltip(event, node) {
        const tooltip = d3.select("#device-tooltip");

        // Update tooltip content
        tooltip.select("#tooltip-name").text(node.name);
        tooltip.select("#tooltip-ip").text(node.ip);
        tooltip.select("#tooltip-type").text(node.type);
        tooltip.select("#tooltip-response").text(node.response_time ? `${node.response_time.toFixed(1)}ms` : '-');
        tooltip.select("#tooltip-uptime").text(node.uptime ? `${node.uptime.toFixed(1)}%` : '-');
        tooltip.select("#tooltip-last-seen").text(node.last_seen ? new Date(node.last_seen).toLocaleDateString() : '-');
        tooltip.select("#tooltip-mac").text(node.mac || '-');

        // Update status badge
        const statusBadge = tooltip.select("#tooltip-status");
        statusBadge.text(node.status.toUpperCase())
            .attr("class", `badge rounded-pill`)
            .style("background-color", this.getNodeColor(node));

        // Update icon
        tooltip.select("#tooltip-icon").text(this.getDeviceIcon(node.type));

        // Position tooltip
        const [mouseX, mouseY] = d3.pointer(event, document.body);
        tooltip
            .style("left", (mouseX + 15) + "px")
            .style("top", (mouseY - 15) + "px")
            .style("display", "block");
    }

    hideTooltip() {
        d3.select("#device-tooltip").style("display", "none");
    }

    getDeviceIcon(type) {
        const icons = {
            'router': '🛜',
            'switch': '🔀',
            'computer': '💻',
            'laptop': '📱',
            'server': '🖥️',
            'printer': '🖨️',
            'camera': '📹',
            'phone': '📱',
            'tablet': '📱',
            'unknown': '❓'
        };
        return icons[type] || icons.unknown;
    }

    async pingDevices(filter) {
        let devicesToPing = [];

        if (filter === 'all') {
            devicesToPing = this.nodes;
        } else if (filter.startsWith('type-')) {
            const type = filter.replace('type-', '');
            devicesToPing = this.nodes.filter(n => n.type === type);
        }

        if (devicesToPing.length === 0) {
            this.showAlert('No devices to ping', 'warning');
            return;
        }

        // Show ping progress modal
        this.showPingProgress(devicesToPing);

        // Ping devices sequentially
        for (let i = 0; i < devicesToPing.length; i++) {
            const device = devicesToPing[i];
            this.updatePingProgress(i, devicesToPing.length);

            try {
                const result = await this.pingDevice(device);
                this.addPingResult(device, result);
            } catch (error) {
                this.addPingResult(device, { success: false, error: error.message });
            }

            // Small delay between pings
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        this.completePingOperation(devicesToPing.length);
    }

    async pingDevice(device) {
        const response = await fetch('/api/devices/ping', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                ip_address: device.ip,
                count: 1
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        return await response.json();
    }

    showPingProgress(devices) {
        const modal = new bootstrap.Modal(document.getElementById('pingProgressModal'));
        modal.show();

        d3.select('#ping-operation-title').text(`Pinging ${devices.length} devices`);
        d3.select('#ping-progress-text').text(`0 / ${devices.length}`);
        d3.select('#ping-progress-bar').style('width', '0%');
        d3.select('#ping-results').html('');
        d3.select('#ping-summary').style('display', 'none');
        d3.select('#ping-export-results').style('display', 'none');
    }

    updatePingProgress(current, total) {
        const percentage = ((current + 1) / total) * 100;
        d3.select('#ping-progress-text').text(`${current + 1} / ${total}`);
        d3.select('#ping-progress-bar').style('width', `${percentage}%`);
    }

    addPingResult(device, result) {
        const resultHtml = `
            <div class="d-flex justify-content-between align-items-center py-2 border-bottom">
                <div>
                    <strong>${device.name}</strong>
                    <span class="text-muted ms-2">${device.ip}</span>
                </div>
                <div>
                    ${result.success ?
                        `<span class="badge bg-success">${result.response_time}ms</span>` :
                        `<span class="badge bg-danger">Failed</span>`
                    }
                </div>
            </div>
        `;

        d3.select('#ping-results').append('div').html(resultHtml);
    }

    completePingOperation(total) {
        d3.select('#ping-summary').style('display', 'block');
        d3.select('#ping-export-results').style('display', 'inline-block');

        const results = d3.selectAll('#ping-results .badge');
        const successful = results.filter(function() { return this.classList.contains('bg-success'); }).size();
        const failed = total - successful;

        d3.select('#ping-summary-text').text(`${successful} successful, ${failed} failed`);
    }

    setLayout(layout) {
        this.selectedLayout = layout;
        console.log(`Switching to ${layout} layout`);

        // Update active state of layout buttons
        d3.selectAll('[data-layout]').classed('active', false);
        d3.select(`[data-layout="${layout}"]`).classed('active', true);

        // Clear fixed positions if switching from non-force layout
        if (layout === 'force') {
            this.nodes.forEach(node => {
                node.fx = null;
                node.fy = null;
            });
        }

        // Re-render with new layout
        this.renderGraph();
    }

    applyFilters() {
        // Get filter states
        const statusFilters = {
            online: d3.select('#status-online').property('checked'),
            offline: d3.select('#status-offline').property('checked'),
            warning: d3.select('#status-warning').property('checked'),
            unknown: d3.select('#status-unknown').property('checked')
        };

        const typeFilters = {};
        d3.selectAll('[id^="type-"]').each(function() {
            const type = this.id.replace('type-', '');
            typeFilters[type] = this.checked;
        });

        // Filter nodes
        this.nodes = this.allNodesData.filter(device => {
            const statusMatch = statusFilters[device.status];
            const typeMatch = typeFilters[device.device_type] !== false;
            return statusMatch && typeMatch;
        }).map(device => ({
            id: device.id,
            name: device.name || device.ip,
            ip: device.ip,
            mac: device.mac_address,
            type: device.device_type || 'unknown',
            status: device.status || 'unknown',
            vendor: device.vendor,
            response_time: device.avg_response_time,
            last_seen: device.last_seen,
            uptime: device.uptime_percentage,
            alerts_count: device.alerts_count || 0
        }));

        // Filter links to only include nodes that are visible
        const visibleNodeIds = new Set(this.nodes.map(n => n.id));
        this.links = this.allLinksData.filter(link =>
            visibleNodeIds.has(link.source) && visibleNodeIds.has(link.target)
        );

        console.log(`Filtered to ${this.nodes.length} nodes and ${this.links.length} links`);

        // Re-render
        this.renderGraph();
    }

    refreshData() {
        console.log("Refreshing topology data...");
        this.retryCount = 0;
        this.loadData();
    }

    toggleFullscreen() {
        const container = document.getElementById('topology-card');

        if (!this.isFullscreen) {
            if (container.requestFullscreen) {
                container.requestFullscreen();
            } else if (container.webkitRequestFullscreen) {
                container.webkitRequestFullscreen();
            } else if (container.msRequestFullscreen) {
                container.msRequestFullscreen();
            }
            this.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
        }

        // Resize after fullscreen change
        setTimeout(() => this.resize(), 100);
    }

    zoom(factor) {
        this.svg.transition()
            .duration(300)
            .call(this.zoomBehavior.scaleBy, factor);
    }

    zoomToFit() {
        if (this.nodes.length === 0) return;

        const bounds = this.getNodeBounds();
        const width = bounds.width;
        const height = bounds.height;
        const midX = bounds.x + width / 2;
        const midY = bounds.y + height / 2;

        if (width === 0 || height === 0) return;

        const scale = 0.9 / Math.max(width / this.width, height / this.height);
        const translate = [this.width / 2 - scale * midX, this.height / 2 - scale * midY];

        this.svg.transition()
            .duration(750)
            .call(this.zoomBehavior.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
    }

    getNodeBounds() {
        if (this.nodes.length === 0) return { x: 0, y: 0, width: 0, height: 0 };

        const xs = this.nodes.map(d => d.x);
        const ys = this.nodes.map(d => d.y);

        return {
            x: Math.min(...xs),
            y: Math.min(...ys),
            width: Math.max(...xs) - Math.min(...xs),
            height: Math.max(...ys) - Math.min(...ys)
        };
    }

    resize() {
        const containerRect = document.getElementById(this.containerId).getBoundingClientRect();
        this.width = containerRect.width || 800;
        this.height = 600;

        this.svg
            .attr("width", this.width)
            .attr("height", this.height);

        // Update force centers if using force layout
        if (this.simulation && this.selectedLayout === 'force') {
            this.simulation.force("center", d3.forceCenter(this.width / 2, this.height / 2));
            this.simulation.alpha(0.3).restart();
        }

        console.log(`Resized to ${this.width} x ${this.height}`);
    }

    showLoading(show) {
        d3.select('#loading-indicator').style('display', show ? 'block' : 'none');
        d3.select('#network-graph').style('display', show ? 'none' : 'block');
    }

    hideError() {
        d3.select('#error-state').style('display', 'none');
    }

    showError(message) {
        d3.select('#error-state').style('display', 'block');
        d3.select('#network-graph').style('display', 'none');
        d3.select('#error-state .alert').text(`Error: ${message}`);
    }

    showEmptyState() {
        this.container.append('div')
            .attr('class', 'empty-state')
            .style('text-align', 'center')
            .style('padding', '4rem')
            .html(`
                <div class="text-muted">
                    <i class="bi bi-diagram-3" style="font-size: 3rem; opacity: 0.5;"></i>
                    <h5 class="mt-3">No network data available</h5>
                    <p>Start by scanning your network or adding devices manually.</p>
                </div>
            `);
    }

    showAlert(message, type = 'info') {
        // Create toast notification
        const toast = d3.select('body').append('div')
            .attr('class', `toast align-items-center text-white bg-${type} border-0`)
            .attr('role', 'alert')
            .style('position', 'fixed')
            .style('top', '20px')
            .style('right', '20px')
            .style('z-index', '1055')
            .html(`
                <div class="d-flex">
                    <div class="toast-body">${message}</div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto"></button>
                </div>
            `);

        // Initialize and show toast
        const toastElement = toast.node();
        const bsToast = new bootstrap.Toast(toastElement);
        bsToast.show();

        // Remove after hiding
        toastElement.addEventListener('hidden.bs.toast', () => {
            toast.remove();
        });
    }

    getDebugInfo() {
        return {
            containerId: this.containerId,
            width: this.width,
            height: this.height,
            nodeCount: this.nodes.length,
            linkCount: this.links.length,
            selectedLayout: this.selectedLayout,
            isFullscreen: this.isFullscreen,
            retryCount: this.retryCount,
            simulationRunning: this.simulation ? this.simulation.alpha() > 0 : false,

            // Browser info
            userAgent: navigator.userAgent,
            apiEndpoint: '/api/monitoring/topology-test',
            containerId: this.containerId,
            d3Available: typeof d3 !== 'undefined',
            nodeCount: this.allNodesData?.length || 0,
            linkCount: this.allLinksData?.length || 0
        };
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log("Initializing Network Topology...");

    // Create network graph instance
    window.networkGraph = new NetworkTopology('network-graph');

    // Set up global event handlers
    let isFullscreen = false;

    // Handle fullscreen changes
    document.addEventListener('fullscreenchange', () => {
        isFullscreen = !!document.fullscreenElement;
        if (window.networkGraph) {
            window.networkGraph.isFullscreen = isFullscreen;
        }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
        if (window.networkGraph) {
            window.networkGraph.resize();
        }
    });

    // ESC key to exit fullscreen
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape' && isFullscreen) {
            window.networkGraph.toggleFullscreen();
        }
    });
});
</script>
{% endblock %}