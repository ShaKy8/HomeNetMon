{% extends "base.html" %}

{% block title %}Network Topology - HomeNetMon{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <h1>Network Topology</h1>
    <div>
        <button type="button" class="btn btn-outline-secondary" id="fullscreen-btn" title="Toggle Fullscreen">
            <i class="bi bi-arrows-fullscreen"></i>
        </button>
    </div>
</div>

<!-- Interactive Network Graph -->
<div class="card mb-4" id="topology-card">
    <div class="card-header bg-dark text-white">
        <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">
                <i class="bi bi-diagram-3 me-2"></i>Network Topology
            </h5>
            <div class="d-flex align-items-center flex-wrap">
                <!-- Filter Controls -->
                <div class="d-flex flex-wrap align-items-center me-3">
                    <!-- Status Filters -->
                    <div class="filter-group me-4 mb-2">
                        <label class="filter-group-label text-muted fw-bold small mb-1 d-block">STATUS:</label>
                        <div class="d-flex flex-wrap gap-2">
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="status-online" checked>
                                <label class="form-check-label small" for="status-online">
                                    <i class="bi bi-check-circle-fill me-1" style="color: #28a745;"></i>Online
                                </label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="status-offline" checked>
                                <label class="form-check-label small" for="status-offline">
                                    <i class="bi bi-x-circle-fill me-1" style="color: #dc3545;"></i>Offline
                                </label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="status-warning" checked>
                                <label class="form-check-label small" for="status-warning">
                                    <i class="bi bi-exclamation-triangle-fill me-1" style="color: #ffc107;"></i>Warning
                                </label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="status-unknown" checked>
                                <label class="form-check-label small" for="status-unknown">
                                    <i class="bi bi-question-circle-fill me-1" style="color: #6c757d;"></i>Unknown
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Device Type Filters -->
                    <div class="filter-group mb-2">
                        <label class="filter-group-label text-muted fw-bold small mb-1 d-block">DEVICE TYPES:</label>
                        <div class="d-flex flex-wrap gap-2">
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="type-router" checked>
                                <label class="form-check-label small" for="type-router">
                                    <i class="bi bi-router me-1"></i>Router
                                </label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="type-computer" checked>
                                <label class="form-check-label small" for="type-computer">
                                    <i class="bi bi-pc-display me-1"></i>Computer
                                </label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="type-apple" checked>
                                <label class="form-check-label small" for="type-apple">
                                    <i class="bi bi-apple me-1"></i>Apple
                                </label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="type-phone" checked>
                                <label class="form-check-label small" for="type-phone">
                                    <i class="bi bi-phone me-1"></i>Mobile
                                </label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="type-smart_home" checked>
                                <label class="form-check-label small" for="type-smart_home">
                                    <i class="bi bi-house-gear me-1"></i>Smart
                                </label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="type-iot" checked>
                                <label class="form-check-label small" for="type-iot">
                                    <i class="bi bi-cpu me-1"></i>IoT
                                </label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="type-camera" checked>
                                <label class="form-check-label small" for="type-camera">
                                    <i class="bi bi-camera-video me-1"></i>Camera
                                </label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="type-unknown" checked>
                                <label class="form-check-label small" for="type-unknown">
                                    <i class="bi bi-question-circle me-1"></i>Unknown
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Filter Actions -->
                <div class="filter-actions me-3 mb-2">
                    <button type="button" class="btn btn-outline-secondary btn-sm me-1" id="select-all-filters" title="Select All Filters">
                        <i class="bi bi-check-square me-1"></i>All
                    </button>
                    <button type="button" class="btn btn-outline-secondary btn-sm" id="clear-all-filters" title="Clear All Filters">
                        <i class="bi bi-square me-1"></i>None
                    </button>
                </div>
                
                <!-- Ping Controls (Promoted to main level) -->
                <div class="ping-controls me-3 mb-2">
                    <button type="button" class="btn btn-success btn-sm me-1" id="ping-visible-devices" title="Test connectivity for visible devices">
                        <i class="bi bi-broadcast me-1"></i>Ping Visible
                    </button>
                    <div class="btn-group btn-group-sm" role="group">
                        <button type="button" class="btn btn-outline-success dropdown-toggle" id="ping-more-options" title="More ping options" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="bi bi-three-dots"></i>
                        </button>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="#" id="ping-all-devices">
                                <i class="bi bi-broadcast me-2"></i>Ping All Monitored Devices
                            </a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="#" id="ping-by-type-router">
                                <i class="bi bi-router me-2"></i>Ping All Routers
                            </a></li>
                            <li><a class="dropdown-item" href="#" id="ping-by-type-camera">
                                <i class="bi bi-camera-video me-2"></i>Ping All Cameras
                            </a></li>
                            <li><a class="dropdown-item" href="#" id="ping-by-type-apple">
                                <i class="bi bi-apple me-2"></i>Ping All Apple Devices
                            </a></li>
                        </ul>
                    </div>
                </div>
                
                <!-- Layout Controls -->
                <div class="btn-group btn-group-sm" role="group" aria-label="Layout Controls">
                    <button type="button" class="btn btn-outline-light" id="graph-layout-force" title="Force-directed Layout">
                        <i class="bi bi-arrows-move"></i>
                    </button>
                    <button type="button" class="btn btn-outline-light" id="graph-layout-circle" title="Circular Layout">
                        <i class="bi bi-circle"></i>
                    </button>
                    <button type="button" class="btn btn-outline-light active" id="graph-layout-grid" title="Grid Layout">
                        <i class="bi bi-grid"></i>
                    </button>
                    <button type="button" class="btn btn-outline-light" id="graph-auto-arrange" title="Smart Auto-Arrange">
                        <i class="bi bi-magic"></i>
                    </button>
                    <button type="button" class="btn btn-outline-light" id="graph-refresh" title="Refresh Data">
                        <i class="bi bi-arrow-clockwise"></i>
                    </button>
                    <button type="button" class="btn btn-outline-light" id="graph-reset" title="Reset Positions">
                        <i class="bi bi-arrow-counterclockwise"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Filter Summary -->
    <div id="filter-summary-container" class="border-bottom bg-light px-3 py-2" style="display: none;">
        <div class="d-flex justify-content-between align-items-center">
            <div class="filter-summary-text">
                <small class="text-muted">
                    <i class="bi bi-funnel me-1"></i>
                    <span id="filter-summary-text">Showing all devices</span>
                </small>
            </div>
            <button type="button" class="btn btn-outline-secondary btn-sm" id="reset-filters" title="Reset all filters">
                <i class="bi bi-arrow-counterclockwise me-1"></i>Reset Filters
            </button>
        </div>
    </div>
    
    <!-- Ping Progress Modal -->
    <div id="ping-progress-modal" class="modal fade" tabindex="-1" aria-labelledby="pingProgressModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h6 class="modal-title" id="pingProgressModalLabel">
                        <i class="bi bi-broadcast me-2"></i>
                        <span id="ping-operation-title">Testing Network Connectivity</span>
                    </h6>
                    <button type="button" class="btn-close" id="ping-cancel-btn" aria-label="Cancel"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <span id="ping-progress-text" class="text-muted">0 / 0 devices</span>
                            <span id="ping-current-device" class="text-primary">Preparing...</span>
                        </div>
                        <div class="progress" style="height: 12px;">
                            <div id="ping-progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                            </div>
                        </div>
                    </div>
                    
                    <div class="row text-center">
                        <div class="col-4">
                            <div class="bg-success bg-opacity-10 rounded p-2">
                                <div class="text-success fs-4 fw-bold" id="ping-success-count">0</div>
                                <small class="text-success">
                                    <i class="bi bi-check-circle me-1"></i>Successful
                                </small>
                            </div>
                        </div>
                        <div class="col-4">
                            <div class="bg-danger bg-opacity-10 rounded p-2">
                                <div class="text-danger fs-4 fw-bold" id="ping-fail-count">0</div>
                                <small class="text-danger">
                                    <i class="bi bi-x-circle me-1"></i>Failed
                                </small>
                            </div>
                        </div>
                        <div class="col-4">
                            <div class="bg-info bg-opacity-10 rounded p-2">
                                <div class="text-info fs-4 fw-bold" id="ping-remaining-count">0</div>
                                <small class="text-info">
                                    <i class="bi bi-clock me-1"></i>Remaining
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="ping-cancel-secondary-btn">Cancel Operation</button>
                    <button type="button" class="btn btn-primary" id="ping-close-btn" style="display: none;">Close</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="card-body p-0">
        <div id="network-graph" style="height: 600px; width: 100%; position: relative; overflow: hidden;">
            <div class="d-flex justify-content-center align-items-center h-100">
                <div class="text-center">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading network graph...</span>
                    </div>
                    <p class="mt-2 text-muted">Loading network topology...</p>
                </div>
            </div>
            <!-- Device Tooltip -->
            <div id="device-tooltip" class="position-absolute" style="display: none; z-index: 1000; pointer-events: none;">
                <div class="card shadow-lg" style="min-width: 280px; max-width: 320px;">
                    <div class="card-body p-3">
                        <div class="d-flex align-items-center mb-2">
                            <span id="tooltip-icon" class="me-2" style="font-size: 1.2em;">❓</span>
                            <div>
                                <h6 id="tooltip-name" class="mb-0">Device Name</h6>
                                <small id="tooltip-ip" class="text-muted">IP Address</small>
                            </div>
                            <span id="tooltip-status" class="ms-auto badge bg-secondary">Status</span>
                        </div>
                        <div class="row g-2 text-sm">
                            <div class="col-6">
                                <div class="d-flex align-items-center">
                                    <i class="bi bi-stopwatch me-1 text-primary"></i>
                                    <span>
                                        <small class="text-muted d-block">Response</small>
                                        <strong id="tooltip-response">N/A</strong>
                                    </span>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="d-flex align-items-center">
                                    <i class="bi bi-graph-up me-1 text-success"></i>
                                    <span>
                                        <small class="text-muted d-block">Uptime</small>
                                        <strong id="tooltip-uptime">N/A</strong>
                                    </span>
                                </div>
                            </div>
                        </div>
                        <div class="row g-2 mt-1">
                            <div class="col-6">
                                <div class="d-flex align-items-center">
                                    <i class="bi bi-hdd me-1 text-info"></i>
                                    <span>
                                        <small class="text-muted d-block">Type</small>
                                        <strong id="tooltip-type">Unknown</strong>
                                    </span>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="d-flex align-items-center">
                                    <i class="bi bi-exclamation-triangle me-1 text-warning"></i>
                                    <span>
                                        <small class="text-muted d-block">Alerts</small>
                                        <strong id="tooltip-alerts">0</strong>
                                    </span>
                                </div>
                            </div>
                        </div>
                        <div class="mt-2 pt-2 border-top">
                            <small class="text-muted">
                                <i class="bi bi-clock me-1"></i>
                                Last seen: <span id="tooltip-last-seen">Unknown</span>
                            </small>
                        </div>
                        <div class="mt-2 text-center">
                            <small class="text-primary">
                                <i class="bi bi-cursor-fill me-1"></i>
                                Click for device details
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Graph Legend -->
        <div class="border-top px-3 py-2 bg-light">
            <div class="row text-center mb-2">
                <div class="col-md-12">
                    <small class="text-muted fw-bold">Status Legend:</small>
                </div>
            </div>
            <div class="row text-center mb-2">
                <div class="col-md-3">
                    <span class="badge" style="background-color: #28a745; width: 12px; height: 12px; border-radius: 50%; display: inline-block;"></span>
                    <small class="ms-1">Online</small>
                </div>
                <div class="col-md-3">
                    <span class="badge" style="background-color: #dc3545; width: 12px; height: 12px; border-radius: 50%; display: inline-block;"></span>
                    <small class="ms-1">Offline</small>
                </div>
                <div class="col-md-3">
                    <span class="badge" style="background-color: #ffc107; width: 12px; height: 12px; border-radius: 50%; display: inline-block;"></span>
                    <small class="ms-1">Warning</small>
                </div>
                <div class="col-md-3">
                    <span class="badge" style="background-color: #6c757d; width: 12px; height: 12px; border-radius: 50%; display: inline-block;"></span>
                    <small class="ms-1">Unknown</small>
                </div>
            </div>
            <div class="row text-center mb-2">
                <div class="col-md-12">
                    <small class="text-muted fw-bold">Device Type Icons:</small>
                </div>
            </div>
            <div class="row text-center mb-2">
                <div class="col-md-2">
                    <i class="bi bi-router me-1"></i>
                    <small>Router</small>
                </div>
                <div class="col-md-2">
                    <i class="bi bi-pc-display me-1"></i>
                    <small>Computer</small>
                </div>
                <div class="col-md-2">
                    <i class="bi bi-apple me-1"></i>
                    <small>Apple</small>
                </div>
                <div class="col-md-2">
                    <i class="bi bi-phone me-1"></i>
                    <small>Mobile</small>
                </div>
                <div class="col-md-2">
                    <i class="bi bi-house-gear me-1"></i>
                    <small>Smart Home</small>
                </div>
                <div class="col-md-2">
                    <i class="bi bi-cpu me-1"></i>
                    <small>IoT</small>
                </div>
            </div>
            <div class="row text-center mb-2">
                <div class="col-md-6">
                    <i class="bi bi-camera-video me-1"></i>
                    <small>Camera</small>
                </div>
                <div class="col-md-6">
                    <i class="bi bi-question-circle me-1"></i>
                    <small>Unknown</small>
                </div>
            </div>
            <div class="row">
                <div class="col-12">
                    <small class="text-muted">
                        <i class="bi bi-info-circle me-1"></i>
                        Drag nodes to reposition them. Use filters to show specific device types or statuses. Auto-arrange groups devices by type and status.
                    </small>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Network Overview Cards -->
<div class="row mb-3">
    <div class="col-md-3">
        <div class="card stats-card">
            <div class="card-body text-center py-2">
                <div class="d-flex align-items-center justify-content-center">
                    <i class="bi bi-router fs-3 me-2"></i>
                    <div>
                        <h5 class="mb-0" id="overview-total">-</h5>
                        <small class="text-muted">Total Devices</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-3">
        <div class="card border-success">
            <div class="card-body text-center py-2">
                <div class="d-flex align-items-center justify-content-center">
                    <i class="bi bi-check-circle fs-3 text-success me-2"></i>
                    <div>
                        <h5 class="mb-0 text-success" id="overview-up">-</h5>
                        <small class="text-muted">Online</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-3">
        <div class="card border-danger">
            <div class="card-body text-center py-2">
                <div class="d-flex align-items-center justify-content-center">
                    <i class="bi bi-x-circle fs-3 text-danger me-2"></i>
                    <div>
                        <h5 class="mb-0 text-danger" id="overview-down">-</h5>
                        <small class="text-muted">Offline</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-3">
        <div class="card border-warning">
            <div class="card-body text-center py-2">
                <div class="d-flex align-items-center justify-content-center">
                    <i class="bi bi-exclamation-triangle fs-3 text-warning me-2"></i>
                    <div>
                        <h5 class="mb-0 text-warning" id="overview-alerts">-</h5>
                        <small class="text-muted">Alerts</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Fullscreen styles */
.fullscreen-mode {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
    background: white !important;
    margin: 0 !important;
}

.fullscreen-mode .card-body {
    padding: 0 !important;
}

.fullscreen-mode #network-graph {
    height: calc(100vh - 120px) !important;
}

.fullscreen-exit-btn {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 10000;
}

/* Tooltip styles */
#device-tooltip {
    transition: opacity 0.2s ease;
}

#device-tooltip .card {
    border: 0;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

/* Node cursor styles */
.node {
    cursor: pointer;
}

.node:hover circle {
    filter: brightness(1.1);
}

/* Ping state animations */
.node-pinging circle {
    animation: ping-pulse 1s infinite;
}

@keyframes ping-pulse {
    0% { stroke-opacity: 1; }
    50% { stroke-opacity: 0.4; }
    100% { stroke-opacity: 1; }
}

.node-ping-success circle {
    stroke: #28a745 !important;
    stroke-width: 3 !important;
}

.node-ping-failed circle {
    stroke: #dc3545 !important;
    stroke-width: 3 !important;
}

/* Progress container animations */
#ping-progress-container {
    transition: all 0.3s ease-in-out;
}

/* Toast notifications */
.toast {
    transition: all 0.3s ease-in-out;
}

/* Filter group styling */
.filter-group {
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    padding: 0.75rem;
    background-color: rgba(255, 255, 255, 0.05);
}

.filter-group-label {
    font-size: 0.75rem;
    letter-spacing: 0.05em;
    margin-bottom: 0.5rem !important;
}

.form-check-inline {
    margin-right: 1rem;
}

.form-check-label.small {
    font-size: 0.875rem;
    cursor: pointer;
}

/* Filter summary styling */
#filter-summary-container {
    transition: all 0.3s ease-in-out;
}

/* Ping controls styling */
.ping-controls .btn-success {
    font-weight: 500;
}
</style>
{% endblock %}

{% block scripts %}
<script>
let networkGraph;
let isFullscreen = false;

// Network Graph Visualization
class NetworkGraph {
    constructor(containerId) {
        this.containerId = containerId;
        this.container = d3.select(`#${containerId}`);
        this.width = 0;
        this.height = 600;
        this.svg = null;
        this.simulation = null;
        this.nodes = [];
        this.links = [];
        this.currentLayout = 'grid';
        this.nodeGroup = null;
        this.linkGroup = null;
        
        // Filter state management with checkbox approach
        this.activeFilters = {
            // Status filters (map to checkbox IDs)
            up: true,      // status-online
            down: true,    // status-offline
            warning: true, // status-warning
            unknown: true, // status-unknown
            
            // Device type filters (map to checkbox IDs)
            router: true,     // type-router
            computer: true,   // type-computer
            apple: true,      // type-apple
            phone: true,      // type-phone
            smart_home: true, // type-smart_home
            iot: true,        // type-iot
            camera: true,     // type-camera
            'unknown-type': true  // type-unknown (renamed to avoid conflict)
        };
        this.allNodesData = []; // Store original unfiltered data
        this.allLinksData = []; // Store original unfiltered links
        
        this.init();
        this.loadData();
        this.startAutoRefresh();
    }
    
    init() {
        const container = this.container.node();
        this.width = container.clientWidth;
        this.height = container.clientHeight;
        
        // Clear existing content
        this.container.selectAll('*').remove();
        
        // Create SVG
        this.svg = this.container.append('svg')
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('viewBox', `0 0 ${this.width} ${this.height}`)
            .style('background', '#f8f9fa');
            
        // Create groups for links and nodes
        this.linkGroup = this.svg.append('g').attr('class', 'links');
        this.nodeGroup = this.svg.append('g').attr('class', 'nodes');
        
        // Create simulation
        this.simulation = d3.forceSimulation()
            .force('link', d3.forceLink().id(d => d.id).strength(0.3))
            .force('charge', d3.forceManyBody().strength(-100))
            .force('center', d3.forceCenter(this.width / 2, this.height / 2))
            .force('collision', d3.forceCollide().radius(30));
    }
    
    async loadData() {
        try {
            const response = await fetch('/api/monitoring/topology-test');
            const data = await response.json();
            
            if (data.nodes && data.edges) {
                this.updateGraph(data.nodes, data.edges);
                // Update stats will be handled by updateFilteredStats after applyFilters
            }
        } catch (error) {
            console.error('Error loading topology data:', error);
        }
    }
    
    updateGraph(nodes, edges) {
        // Store original data for filtering
        this.allNodesData = nodes.map(d => ({...d}));
        this.allLinksData = edges.map(d => ({...d}));
        
        // Apply current filters
        this.applyFilters();
    }
    
    // Filter Management Methods
    setFilter(status, enabled) {
        console.log(`TopologyFilter: Setting ${status} filter to ${enabled}`);
        
        if (status === 'all') {
            // Handle "All" button - enable/disable all filters
            this.activeFilters.all = enabled;
            this.activeFilters.up = enabled;
            this.activeFilters.down = enabled;
            this.activeFilters.warning = enabled;
            this.activeFilters.unknown = enabled;
        } else {
            // Handle individual status filters
            this.activeFilters[status] = enabled;
            
            // Update "All" filter state based on individual filters
            this.activeFilters.all = this.activeFilters.up && 
                                   this.activeFilters.down && 
                                   this.activeFilters.warning && 
                                   this.activeFilters.unknown;
        }
        
        this.applyFilters();
        this.updateFilterUI();
    }
    
    applyFilters() {
        console.log('TopologyFilter: Applying filters', this.activeFilters);
        
        // Filter nodes based on active filters (both status and device type)
        this.nodes = this.allNodesData.filter(node => {
            // Check status filter
            const statusFilterKey = node.status || 'unknown';
            const statusMatch = this.activeFilters[statusFilterKey];
            
            // Check device type filter
            const deviceType = node.device_type || 'unknown';
            const typeFilterKey = deviceType === 'unknown' ? 'unknown-type' : deviceType;
            const typeMatch = this.activeFilters[typeFilterKey];
            
            // Both status and device type must match (AND logic)
            return statusMatch && typeMatch;
        });
        
        // Filter links to only include connections between visible nodes
        const visibleNodeIds = new Set(this.nodes.map(n => n.id));
        this.links = this.allLinksData.filter(link => {
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            return visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId);
        });
        
        console.log(`TopologyFilter: Filtered to ${this.nodes.length} nodes and ${this.links.length} links`);
        
        // Update simulation with filtered data
        this.simulation.nodes(this.nodes);
        this.simulation.force('link').links(this.links);
        
        // Re-render the graph
        this.render();
        
        // Update statistics with filtered data
        this.updateFilteredStats();
        
        // Update filter summary
        this.updateFilterSummary();
    }
    
    updateFilteredStats() {
        const upCount = this.nodes.filter(n => n.status === 'up').length;
        const downCount = this.nodes.filter(n => n.status === 'down').length;
        const warningCount = this.nodes.filter(n => n.status === 'warning').length;
        const unknownCount = this.nodes.filter(n => n.status === 'unknown').length;
        const totalCount = this.nodes.length;
        const alertCount = this.nodes.reduce((sum, n) => sum + (n.active_alerts || 0), 0);
        
        // Count by device type
        const typeStats = {
            router: this.nodes.filter(n => n.device_type === 'router').length,
            computer: this.nodes.filter(n => n.device_type === 'computer').length,
            apple: this.nodes.filter(n => n.device_type === 'apple').length,
            phone: this.nodes.filter(n => n.device_type === 'phone').length,
            smart_home: this.nodes.filter(n => n.device_type === 'smart_home').length,
            iot: this.nodes.filter(n => n.device_type === 'iot').length,
            camera: this.nodes.filter(n => n.device_type === 'camera').length,
            unknown: this.nodes.filter(n => !n.device_type || n.device_type === 'unknown').length
        };
        
        // Update overview cards
        document.getElementById('overview-total').textContent = totalCount;
        document.getElementById('overview-up').textContent = upCount;
        document.getElementById('overview-down').textContent = downCount;
        document.getElementById('overview-alerts').textContent = alertCount;
        
        console.log(`TopologyFilter: Stats updated - Total: ${totalCount}, Up: ${upCount}, Down: ${downCount}, Warning: ${warningCount}, Unknown: ${unknownCount}`);
        console.log('TopologyFilter: Device Type Stats', typeStats);
    }
    
    updateFilterSummary() {
        const totalDevices = this.allNodesData.length;
        const visibleDevices = this.nodes.length;
        const summaryContainer = document.getElementById('filter-summary-container');
        const summaryText = document.getElementById('filter-summary-text');
        
        if (visibleDevices === totalDevices) {
            // All devices visible, hide summary
            summaryContainer.style.display = 'none';
            summaryText.textContent = 'Showing all devices';
            return;
        }
        
        // Some filters are active, show summary
        summaryContainer.style.display = 'block';
        
        // Build filter description
        const activeStatusFilters = [];
        const activeTypeFilters = [];
        
        // Check which status filters are active
        if (this.activeFilters.up && !this.activeFilters.down && !this.activeFilters.warning && !this.activeFilters.unknown) {
            activeStatusFilters.push('Online');
        } else if (!this.activeFilters.up && this.activeFilters.down && !this.activeFilters.warning && !this.activeFilters.unknown) {
            activeStatusFilters.push('Offline');
        } else if (!this.activeFilters.up && !this.activeFilters.down && this.activeFilters.warning && !this.activeFilters.unknown) {
            activeStatusFilters.push('Warning');
        } else if (!this.activeFilters.up && !this.activeFilters.down && !this.activeFilters.warning && this.activeFilters.unknown) {
            activeStatusFilters.push('Unknown');
        } else {
            // Multiple status filters, just show count
            const statusCount = [this.activeFilters.up, this.activeFilters.down, this.activeFilters.warning, this.activeFilters.unknown].filter(Boolean).length;
            if (statusCount < 4) {
                activeStatusFilters.push(`${statusCount} status types`);
            }
        }
        
        // Check which device type filters are active
        const typeMap = {
            router: 'Routers',
            computer: 'Computers', 
            apple: 'Apple devices',
            phone: 'Mobile devices',
            smart_home: 'Smart home',
            iot: 'IoT devices',
            camera: 'Cameras',
            'unknown-type': 'Unknown types'
        };
        
        const activeTypes = Object.entries(this.activeFilters)
            .filter(([key, value]) => value && typeMap[key])
            .map(([key]) => typeMap[key]);
            
        if (activeTypes.length === 1) {
            activeTypeFilters.push(activeTypes[0]);
        } else if (activeTypes.length > 1 && activeTypes.length < 8) {
            activeTypeFilters.push(`${activeTypes.length} device types`);
        }
        
        // Build summary text
        let summaryParts = [];
        if (activeStatusFilters.length > 0) {
            summaryParts.push(activeStatusFilters[0]);
        }
        if (activeTypeFilters.length > 0) {
            summaryParts.push(activeTypeFilters[0]);
        }
        
        const filterDesc = summaryParts.length > 0 ? ` (${summaryParts.join(', ')})` : '';
        summaryText.textContent = `Showing ${visibleDevices} of ${totalDevices} devices${filterDesc}`;
    }
    
    // updateFilterUI method removed - now using checkbox synchronization instead
    
    
    render() {
        // Update links with smooth transitions
        const link = this.linkGroup.selectAll('.link')
            .data(this.links, d => `${d.source.id || d.source}-${d.target.id || d.target}`);
            
        // Remove old links with fade out
        link.exit()
            .transition()
            .duration(300)
            .attr('stroke-opacity', 0)
            .remove();
        
        // Add new links with fade in
        const linkEnter = link.enter().append('line')
            .attr('class', 'link')
            .attr('stroke', d => d.color || '#999')
            .attr('stroke-width', d => Math.sqrt(d.strength || 1) * 2)
            .attr('stroke-opacity', 0);
            
        linkEnter.transition()
            .duration(300)
            .attr('stroke-opacity', 0.6);
        
        // Update nodes with smooth transitions
        const node = this.nodeGroup.selectAll('.node')
            .data(this.nodes, d => d.id);
            
        // Remove old nodes with fade out and scale down
        node.exit()
            .transition()
            .duration(300)
            .style('opacity', 0)
            .attr('transform', d => `translate(${d.x},${d.y}) scale(0.1)`)
            .remove();
        
        const nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .style('cursor', 'pointer')
            .style('opacity', 0)
            .attr('transform', d => `translate(${d.x || this.width/2},${d.y || this.height/2}) scale(0.1)`);
            
        // Add circles
        nodeEnter.append('circle')
            .attr('r', d => d.size || 20)
            .attr('fill', d => d.color || '#999')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2);
            
        // Animate new nodes in
        nodeEnter.transition()
            .duration(300)
            .style('opacity', 1)
            .attr('transform', d => `translate(${d.x || this.width/2},${d.y || this.height/2}) scale(1)`);
            
        // Add icons based on device type
        nodeEnter.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', 5)
            .attr('font-size', '16px')
            .text(d => this.getDeviceTypeIcon(d.device_type) || d.icon || '❓');
            
        // Add labels
        nodeEnter.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', d => d.size + 20)
            .attr('font-size', '12px')
            .attr('fill', '#333')
            .text(d => d.label.length > 15 ? d.label.substring(0, 15) + '...' : d.label);
            
        // Add click handlers
        nodeEnter.on('click', (event, d) => this.onNodeClick(event, d))
            .on('mouseover', (event, d) => this.onNodeHover(event, d))
            .on('mouseout', (event, d) => this.onNodeHoverOut(event, d));
            
        // Add drag behavior
        nodeEnter.call(d3.drag()
            .on('start', (event, d) => this.dragstarted(event, d))
            .on('drag', (event, d) => this.dragged(event, d))
            .on('end', (event, d) => this.dragended(event, d)));
        
        // Update simulation
        this.simulation.on('tick', () => {
            this.linkGroup.selectAll('.link')
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
                
            this.nodeGroup.selectAll('.node')
                .attr('transform', d => `translate(${d.x},${d.y})`);
        });
        
        // Apply layout
        this.setLayout(this.currentLayout);
    }
    
    setLayout(layout) {
        this.currentLayout = layout;
        
        switch (layout) {
            case 'force':
                this.simulation
                    .force('x', null)
                    .force('y', null)
                    .alpha(0.3).restart();
                break;
                
            case 'circle':
                this.simulation
                    .force('x', d3.forceX().x((d, i) => {
                        const angle = (i / this.nodes.length) * 2 * Math.PI;
                        return this.width/2 + Math.cos(angle) * 150;
                    }).strength(0.5))
                    .force('y', d3.forceY().y((d, i) => {
                        const angle = (i / this.nodes.length) * 2 * Math.PI;
                        return this.height/2 + Math.sin(angle) * 150;
                    }).strength(0.5))
                    .alpha(0.3).restart();
                break;
                
            case 'grid':
                const cols = Math.ceil(Math.sqrt(this.nodes.length));
                this.simulation
                    .force('x', d3.forceX().x((d, i) => {
                        const col = i % cols;
                        return (col + 1) * (this.width / (cols + 1));
                    }).strength(0.5))
                    .force('y', d3.forceY().y((d, i) => {
                        const row = Math.floor(i / cols);
                        const rows = Math.ceil(this.nodes.length / cols);
                        return (row + 1) * (this.height / (rows + 1));
                    }).strength(0.5))
                    .alpha(0.3).restart();
                break;
        }
    }
    
    onNodeClick(event, d) {
        // Navigate to device detail page
        window.location.href = `/device/${d.id}`;
    }
    
    onNodeHover(event, d) {
        // Highlight node
        d3.select(event.currentTarget).select('circle')
            .attr('stroke-width', 4)
            .attr('stroke', '#007bff');
        
        // Show tooltip with device details
        this.showTooltip(event, d);
    }
    
    onNodeHoverOut(event, d) {
        // Remove highlight
        d3.select(event.currentTarget).select('circle')
            .attr('stroke-width', 2)
            .attr('stroke', '#fff');
        
        // Hide tooltip
        this.hideTooltip();
    }
    
    dragstarted(event, d) {
        if (!event.active) this.simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }
    
    dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }
    
    dragended(event, d) {
        if (!event.active) this.simulation.alphaTarget(0);
        // Keep the node fixed at its current position - don't reset fx/fy
        // d.fx = null;
        // d.fy = null;
    }
    
    refresh() {
        this.loadData();
    }
    
    resize() {
        const container = this.container.node();
        this.width = container.clientWidth;
        this.height = container.clientHeight;
        
        this.svg.attr('viewBox', `0 0 ${this.width} ${this.height}`);
        this.simulation.force('center', d3.forceCenter(this.width / 2, this.height / 2));
        this.simulation.alpha(0.3).restart();
    }
    
    // Initialize filter event handlers with new checkbox approach
    initializeFilterHandlers() {
        // Status filter checkboxes
        const statusCheckboxes = {
            'status-online': 'up',
            'status-offline': 'down',
            'status-warning': 'warning',
            'status-unknown': 'unknown'
        };
        
        // Device type filter checkboxes
        const typeCheckboxes = {
            'type-router': 'router',
            'type-computer': 'computer',
            'type-apple': 'apple',
            'type-phone': 'phone',
            'type-smart_home': 'smart_home',
            'type-iot': 'iot',
            'type-camera': 'camera',
            'type-unknown': 'unknown-type'
        };
        
        // Add event listeners to status checkboxes
        Object.entries(statusCheckboxes).forEach(([checkboxId, filterKey]) => {
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.addEventListener('change', (e) => {
                    this.activeFilters[filterKey] = e.target.checked;
                    this.applyFilters();
                });
            }
        });
        
        // Add event listeners to device type checkboxes
        Object.entries(typeCheckboxes).forEach(([checkboxId, filterKey]) => {
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.addEventListener('change', (e) => {
                    this.activeFilters[filterKey] = e.target.checked;
                    this.applyFilters();
                });
            }
        });
        
        // Select All / Clear All buttons
        document.getElementById('select-all-filters')?.addEventListener('click', () => {
            this.selectAllFilters();
        });
        
        document.getElementById('clear-all-filters')?.addEventListener('click', () => {
            this.clearAllFilters();
        });
        
        // Reset filters button
        document.getElementById('reset-filters')?.addEventListener('click', () => {
            this.resetFilters();
        });
        
        console.log('Topology: Checkbox filter handlers initialized');
    }
    
    selectAllFilters() {
        // Check all checkboxes
        Object.keys(this.activeFilters).forEach(key => {
            this.activeFilters[key] = true;
        });
        
        // Update UI checkboxes
        this.syncCheckboxes();
        this.applyFilters();
    }
    
    clearAllFilters() {
        // Uncheck all checkboxes
        Object.keys(this.activeFilters).forEach(key => {
            this.activeFilters[key] = false;
        });
        
        // Update UI checkboxes
        this.syncCheckboxes();
        this.applyFilters();
    }
    
    resetFilters() {
        // Reset to all filters active
        this.selectAllFilters();
    }
    
    syncCheckboxes() {
        // Sync checkbox UI with filter state
        const checkboxMap = {
            'status-online': 'up',
            'status-offline': 'down',
            'status-warning': 'warning',
            'status-unknown': 'unknown',
            'type-router': 'router',
            'type-computer': 'computer',
            'type-apple': 'apple',
            'type-phone': 'phone',
            'type-smart_home': 'smart_home',
            'type-iot': 'iot',
            'type-camera': 'camera',
            'type-unknown': 'unknown-type'
        };
        
        Object.entries(checkboxMap).forEach(([checkboxId, filterKey]) => {
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.checked = this.activeFilters[filterKey];
            }
        });
    }
    
    autoArrange() {
        // Smart auto-arrange based on device types, status, and relationships
        const margin = 80;
        const groupSpacing = 120;
        const deviceSpacing = 100;
        
        // Group devices by type and status
        const deviceGroups = {
            'core': [],      // routers, switches, core infrastructure
            'servers': [],   // computers, servers
            'smart_home': [],// smart home devices
            'cameras': [],   // security cameras
            'mobile': [],    // phones, tablets, mobile devices
            'unknown': []    // unknown or other devices
        };
        
        // Categorize devices into logical groups based on device_type field
        this.nodes.forEach(node => {
            const type = (node.device_type || 'unknown').toLowerCase();
            
            // Core infrastructure (highest priority)
            if (type === 'router') {
                deviceGroups.core.push(node);
            }
            // Servers and computers
            else if (type === 'computer') {
                deviceGroups.servers.push(node);
            }
            // Smart home and IoT devices
            else if (type === 'smart_home' || type === 'iot') {
                deviceGroups.smart_home.push(node);
            }
            // Security cameras
            else if (type === 'camera') {
                deviceGroups.cameras.push(node);
            }
            // Mobile devices (phones, tablets, Apple devices)
            else if (type === 'phone' || type === 'apple') {
                deviceGroups.mobile.push(node);
            }
            // Everything else goes to unknown
            else {
                deviceGroups.unknown.push(node);
            }
        });
        
        // Sort each group: online first, then warning, then offline
        const statusOrder = { 'up': 0, 'warning': 1, 'down': 2, 'unknown': 3 };
        Object.values(deviceGroups).forEach(group => {
            group.sort((a, b) => {
                const statusDiff = statusOrder[a.status] - statusOrder[b.status];
                if (statusDiff !== 0) return statusDiff;
                return a.label.localeCompare(b.label); // Secondary sort by name
            });
        });
        
        // Calculate layout positions
        let currentY = margin;
        const centerX = this.width / 2;
        
        // Position core infrastructure at the top center
        if (deviceGroups.core.length > 0) {
            this.positionGroup(deviceGroups.core, centerX, currentY, deviceSpacing, 'horizontal');
            currentY += groupSpacing;
        }
        
        // Position servers in the second tier
        if (deviceGroups.servers.length > 0) {
            this.positionGroup(deviceGroups.servers, centerX, currentY, deviceSpacing, 'horizontal');
            currentY += groupSpacing;
        }
        
        // Position other groups in rows below
        const remainingGroups = ['smart_home', 'cameras', 'mobile', 'unknown'].filter(key => deviceGroups[key].length > 0);
        
        if (remainingGroups.length > 0) {
            const groupsPerRow = Math.min(2, remainingGroups.length);
            const groupWidth = (this.width - 2 * margin) / groupsPerRow;
            
            for (let i = 0; i < remainingGroups.length; i += groupsPerRow) {
                const rowGroups = remainingGroups.slice(i, i + groupsPerRow);
                
                rowGroups.forEach((groupKey, index) => {
                    const group = deviceGroups[groupKey];
                    const x = margin + (index + 0.5) * groupWidth;
                    this.positionGroup(group, x, currentY, deviceSpacing * 0.8, 'grid');
                });
                
                currentY += groupSpacing;
            }
        }
        
        // Restart simulation with the new positions
        this.simulation.alpha(0.3).restart();
    }
    
    positionGroup(devices, centerX, startY, spacing, layout) {
        if (devices.length === 0) return;
        
        if (layout === 'horizontal') {
            // Arrange devices in a horizontal line
            const totalWidth = (devices.length - 1) * spacing;
            const startX = centerX - totalWidth / 2;
            
            devices.forEach((device, index) => {
                device.fx = startX + index * spacing;
                device.fy = startY;
            });
        } else if (layout === 'grid') {
            // Arrange devices in a compact grid
            const cols = Math.ceil(Math.sqrt(devices.length));
            const rows = Math.ceil(devices.length / cols);
            const gridSpacing = spacing * 0.7;
            
            devices.forEach((device, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                const gridWidth = (cols - 1) * gridSpacing;
                const gridHeight = (rows - 1) * gridSpacing;
                
                device.fx = centerX - gridWidth / 2 + col * gridSpacing;
                device.fy = startY - gridHeight / 2 + row * gridSpacing;
            });
        }
    }
    
    resetPositions() {
        // Clear all fixed positions and restart with current layout
        this.nodes.forEach(d => {
            d.fx = null;
            d.fy = null;
        });
        this.setLayout(this.currentLayout);
    }
    
    showTooltip(event, d) {
        const tooltip = document.getElementById('device-tooltip');
        if (!tooltip) return;
        
        // Update tooltip content with device type-specific icon
        const iconElement = document.getElementById('tooltip-icon');
        const nameElement = document.getElementById('tooltip-name');
        const ipElement = document.getElementById('tooltip-ip');
        
        if (iconElement) iconElement.textContent = this.getDeviceTypeIcon(d.device_type) || d.icon || '❓';
        if (nameElement) nameElement.textContent = d.label || 'Unknown Device';
        if (ipElement) ipElement.textContent = d.ip || 'Unknown IP';
        
        // Update status badge
        const statusBadge = document.getElementById('tooltip-status');
        if (statusBadge) {
            statusBadge.textContent = d.status ? d.status.toUpperCase() : 'UNKNOWN';
            statusBadge.className = `ms-auto badge ${
                d.status === 'up' ? 'bg-success' :
                d.status === 'down' ? 'bg-danger' :
                d.status === 'warning' ? 'bg-warning' :
                'bg-secondary'
            }`;
        }
        
        // Update metrics
        const responseElement = document.getElementById('tooltip-response');
        if (responseElement) {
            responseElement.textContent = d.response_time ? `${d.response_time.toFixed(1)}ms` : 'N/A';
        }
        
        const uptimeElement = document.getElementById('tooltip-uptime');
        if (uptimeElement) {
            uptimeElement.textContent = d.uptime_percentage ? `${d.uptime_percentage.toFixed(1)}%` : 'N/A';
        }
        
        // Format device type for display
        const typeElement = document.getElementById('tooltip-type');
        if (typeElement) {
            const deviceTypeDisplay = (d.device_type || 'unknown').replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
            typeElement.textContent = deviceTypeDisplay;
        }
        
        const alertsElement = document.getElementById('tooltip-alerts');
        if (alertsElement) {
            alertsElement.textContent = d.active_alerts || '0';
        }
        
        // Update last seen
        const lastSeenElement = document.getElementById('tooltip-last-seen');
        if (lastSeenElement) {
            const lastSeen = d.last_seen ? 
                new Date(d.last_seen).toLocaleString([], {
                    month: 'short', day: 'numeric', 
                    hour: '2-digit', minute: '2-digit'
                }) : 'Unknown';
            lastSeenElement.textContent = lastSeen;
        }
        
        // Position tooltip near cursor
        const rect = this.container.node().getBoundingClientRect();
        const mouseX = event.pageX - rect.left;
        const mouseY = event.pageY - rect.top;
        
        // Adjust position to keep tooltip in view
        let left = mouseX + 15;
        let top = mouseY - 100;
        
        // Prevent tooltip from going off-screen
        const tooltipWidth = 320;
        const tooltipHeight = 200;
        
        if (left + tooltipWidth > this.width) {
            left = mouseX - tooltipWidth - 15;
        }
        if (top < 0) {
            top = mouseY + 15;
        }
        if (top + tooltipHeight > this.height) {
            top = this.height - tooltipHeight - 10;
        }
        
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.style.display = 'block';
        tooltip.style.opacity = '1';
    }
    
    hideTooltip() {
        const tooltip = document.getElementById('device-tooltip');
        if (tooltip) {
            tooltip.style.display = 'none';
            tooltip.style.opacity = '0';
        }
    }
    
    getDeviceTypeIcon(deviceType) {
        const iconMap = {
            'router': '🌐',
            'computer': '💻',
            'apple': '🍎',
            'phone': '📱',
            'smart_home': '🏠',
            'iot': '🔌',
            'camera': '📹',
            'unknown': '❓'
        };
        
        return iconMap[deviceType] || iconMap['unknown'];
    }
    
    startAutoRefresh() {
        // Auto-refresh disabled to preserve node positions when moved
        // setInterval(() => {
        //     this.refresh();
        // }, 30000); // Refresh every 30 seconds
    }
    
    // Ping functionality
    async pingDevices(mode, deviceType = null) {
        let devices = [];
        let operationTitle = '';
        
        // Determine which devices to ping based on mode
        switch (mode) {
            case 'visible':
                devices = this.nodes.map(node => ({ id: node.id, name: node.label, ip: node.ip }));
                operationTitle = `Pinging ${devices.length} Visible Devices`;
                break;
                
            case 'all':
                try {
                    const response = await fetch('/api/devices?monitored=true');
                    const data = await response.json();
                    devices = data.devices.map(device => ({ 
                        id: device.id, 
                        name: device.display_name, 
                        ip: device.ip_address 
                    }));
                    operationTitle = `Pinging All ${devices.length} Monitored Devices`;
                } catch (error) {
                    console.error('Error fetching devices:', error);
                    return;
                }
                break;
                
            case 'type':
                if (!deviceType) return;
                devices = this.allNodesData
                    .filter(node => node.device_type === deviceType)
                    .map(node => ({ id: node.id, name: node.label, ip: node.ip }));
                const typeDisplay = deviceType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
                operationTitle = `Pinging ${devices.length} ${typeDisplay} Devices`;
                break;
                
            default:
                return;
        }
        
        if (devices.length === 0) {
            alert('No devices found to ping.');
            return;
        }
        
        await this.executePingOperation(devices, operationTitle);
    }
    
    async executePingOperation(devices, operationTitle) {
        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('ping-progress-modal'));
        const progressBar = document.getElementById('ping-progress-bar');
        const progressText = document.getElementById('ping-progress-text');
        const titleElement = document.getElementById('ping-operation-title');
        const successCount = document.getElementById('ping-success-count');
        const failCount = document.getElementById('ping-fail-count');
        const remainingCount = document.getElementById('ping-remaining-count');
        const currentDevice = document.getElementById('ping-current-device');
        const cancelBtn = document.getElementById('ping-cancel-btn');
        const cancelSecondaryBtn = document.getElementById('ping-cancel-secondary-btn');
        const closeBtn = document.getElementById('ping-close-btn');
        
        // Initialize modal UI
        titleElement.textContent = operationTitle;
        progressBar.style.width = '0%';
        progressBar.className = 'progress-bar progress-bar-striped progress-bar-animated';
        progressText.textContent = `0 / ${devices.length} devices`;
        successCount.textContent = '0';
        failCount.textContent = '0';
        remainingCount.textContent = devices.length.toString();
        currentDevice.textContent = 'Preparing...';
        cancelSecondaryBtn.style.display = 'inline-block';
        closeBtn.style.display = 'none';
        
        modal.show();
        
        let cancelled = false;
        let completed = 0;
        let successful = 0;
        let failed = 0;
        
        // Cancel button handlers
        const cancelHandler = () => {
            cancelled = true;
            currentDevice.textContent = 'Cancelling...';
        };
        cancelBtn.addEventListener('click', cancelHandler);
        cancelSecondaryBtn.addEventListener('click', cancelHandler);
        
        // Process devices one by one for better UX
        for (let i = 0; i < devices.length && !cancelled; i++) {
            const device = devices[i];
            currentDevice.textContent = `Pinging ${device.name}...`;
            
            // Update node to show pinging state
            this.setNodePingState(device.id, 'pinging');
            
            try {
                const response = await fetch('/api/device-control/ping', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        ip_address: device.ip,
                        count: 1
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    successful++;
                    this.setNodePingState(device.id, 'success', result.avg_response_time);
                } else {
                    failed++;
                    this.setNodePingState(device.id, 'failed');
                }
                
            } catch (error) {
                console.error(`Error pinging ${device.name}:`, error);
                failed++;
                this.setNodePingState(device.id, 'failed');
            }
            
            completed++;
            const remaining = devices.length - completed;
            
            // Update progress
            const progress = (completed / devices.length) * 100;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${completed} / ${devices.length} devices`;
            successCount.textContent = successful.toString();
            failCount.textContent = failed.toString();
            remainingCount.textContent = remaining.toString();
        }
        
        // Clean up handlers
        cancelBtn.removeEventListener('click', cancelHandler);
        cancelSecondaryBtn.removeEventListener('click', cancelHandler);
        
        // Update final state
        if (cancelled) {
            currentDevice.textContent = 'Operation cancelled';
            progressBar.classList.remove('progress-bar-animated');
            progressBar.classList.add('bg-warning');
        } else {
            currentDevice.textContent = 'Completed successfully!';
            progressBar.classList.remove('progress-bar-animated');
            progressBar.classList.add(successful === devices.length ? 'bg-success' : 'bg-info');
            
            // Show completion notification
            this.showPingCompletionNotification(successful, failed, devices.length);
        }
        
        // Show close button, hide cancel
        cancelSecondaryBtn.style.display = 'none';
        closeBtn.style.display = 'inline-block';
        closeBtn.onclick = () => modal.hide();
        
        // Auto-close after 10 seconds if successful
        if (!cancelled && successful > 0) {
            setTimeout(() => {
                if (modal._isShown) {
                    modal.hide();
                }
            }, 10000);
        }
    }
    
    setNodePingState(deviceId, state, responseTime = null) {
        // Find the node in the current visible nodes
        const node = this.nodes.find(n => n.id === deviceId);
        if (!node) return;
        
        // Update node visual state
        const nodeElement = this.nodeGroup.selectAll('.node')
            .filter(d => d.id === deviceId);
            
        if (nodeElement.empty()) return;
        
        // Remove all ping state classes
        nodeElement.classed('node-pinging', false)
                  .classed('node-ping-success', false)
                  .classed('node-ping-failed', false);
        
        const circle = nodeElement.select('circle');
        
        switch (state) {
            case 'pinging':
                nodeElement.classed('node-pinging', true);
                circle.attr('stroke', '#007bff')
                     .attr('stroke-width', 4)
                     .style('opacity', 0.8);
                break;
                
            case 'success':
                nodeElement.classed('node-ping-success', true);
                circle.attr('stroke', '#28a745')
                     .attr('stroke-width', 3)
                     .style('opacity', 1);
                // Update node data for future reference
                node.last_ping_time = new Date().toISOString();
                node.last_ping_success = true;
                if (responseTime) {
                    node.response_time = responseTime;
                }
                // Auto-reset visual state after 3 seconds
                setTimeout(() => {
                    nodeElement.classed('node-ping-success', false);
                    circle.attr('stroke', '#fff').attr('stroke-width', 2);
                }, 3000);
                break;
                
            case 'failed':
                nodeElement.classed('node-ping-failed', true);
                circle.attr('stroke', '#dc3545')
                     .attr('stroke-width', 3)
                     .style('opacity', 1);
                // Update node data
                node.last_ping_time = new Date().toISOString();
                node.last_ping_success = false;
                // Auto-reset visual state after 3 seconds
                setTimeout(() => {
                    nodeElement.classed('node-ping-failed', false);
                    circle.attr('stroke', '#fff').attr('stroke-width', 2);
                }, 3000);
                break;
                
            default:
                circle.attr('stroke', '#fff')
                     .attr('stroke-width', 2)
                     .style('opacity', 1);
        }
    }
    
    showPingCompletionNotification(successful, failed, total) {
        const message = `Ping operation completed: ${successful} successful, ${failed} failed out of ${total} devices.`;
        
        // Create a toast notification (simple implementation)
        const toast = document.createElement('div');
        toast.className = 'toast align-items-center text-white bg-primary border-0 position-fixed';
        toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999;';
        toast.setAttribute('role', 'alert');
        toast.innerHTML = `
            <div class="d-flex">
                <div class="toast-body">
                    <i class="bi bi-broadcast me-2"></i>${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        `;
        
        document.body.appendChild(toast);
        
        // Use Bootstrap toast if available, otherwise auto-remove
        if (window.bootstrap && bootstrap.Toast) {
            const bsToast = new bootstrap.Toast(toast);
            bsToast.show();
        } else {
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 5000);
        }
    }
}

function setActiveGraphButton(activeId) {
    document.querySelectorAll('#topology-card .btn-group .btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.getElementById(activeId).classList.add('active');
}

function toggleFullscreen() {
    const card = document.getElementById('topology-card');
    const btn = document.getElementById('fullscreen-btn');
    const icon = btn.querySelector('i');
    
    if (!isFullscreen) {
        // Enter fullscreen
        card.classList.add('fullscreen-mode');
        
        // Add exit button
        const exitBtn = document.createElement('button');
        exitBtn.className = 'btn btn-danger fullscreen-exit-btn';
        exitBtn.innerHTML = '<i class="bi bi-x-lg"></i>';
        exitBtn.onclick = toggleFullscreen;
        document.body.appendChild(exitBtn);
        
        icon.className = 'bi bi-fullscreen-exit';
        isFullscreen = true;
        
        // Resize graph
        setTimeout(() => {
            networkGraph.resize();
        }, 100);
    } else {
        // Exit fullscreen
        card.classList.remove('fullscreen-mode');
        
        // Remove exit button
        const exitBtn = document.querySelector('.fullscreen-exit-btn');
        if (exitBtn) {
            exitBtn.remove();
        }
        
        icon.className = 'bi bi-arrows-fullscreen';
        isFullscreen = false;
        
        // Resize graph
        setTimeout(() => {
            networkGraph.resize();
        }, 100);
    }
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Initialize network graph
    networkGraph = new NetworkGraph('network-graph');
    
    // Initialize filter handlers
    networkGraph.initializeFilterHandlers();
    
    // Network graph controls
    document.getElementById('graph-layout-force').addEventListener('click', () => {
        networkGraph.setLayout('force');
        setActiveGraphButton('graph-layout-force');
    });
    
    document.getElementById('graph-layout-circle').addEventListener('click', () => {
        networkGraph.setLayout('circle');
        setActiveGraphButton('graph-layout-circle');
    });
    
    document.getElementById('graph-layout-grid').addEventListener('click', () => {
        networkGraph.setLayout('grid');
        setActiveGraphButton('graph-layout-grid');
    });
    
    document.getElementById('graph-refresh').addEventListener('click', () => {
        networkGraph.refresh();
    });
    
    document.getElementById('graph-reset').addEventListener('click', () => {
        networkGraph.resetPositions();
    });
    
    document.getElementById('graph-auto-arrange').addEventListener('click', () => {
        networkGraph.autoArrange();
        setActiveGraphButton('graph-auto-arrange');
    });
    
    // Ping operations with new button structure
    document.getElementById('ping-visible-devices').addEventListener('click', (e) => {
        e.preventDefault();
        networkGraph.pingDevices('visible');
    });
    
    document.getElementById('ping-all-devices').addEventListener('click', (e) => {
        e.preventDefault();
        networkGraph.pingDevices('all');
    });
    
    document.getElementById('ping-by-type-router').addEventListener('click', (e) => {
        e.preventDefault();
        networkGraph.pingDevices('type', 'router');
    });
    
    document.getElementById('ping-by-type-camera').addEventListener('click', (e) => {
        e.preventDefault();
        networkGraph.pingDevices('type', 'camera');
    });
    
    document.getElementById('ping-by-type-apple').addEventListener('click', (e) => {
        e.preventDefault();
        networkGraph.pingDevices('type', 'apple');
    });
    
    // Fullscreen toggle
    document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
    
    // Handle window resize
    window.addEventListener('resize', () => {
        if (networkGraph) {
            networkGraph.resize();
        }
    });
    
    // ESC key to exit fullscreen
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape' && isFullscreen) {
            toggleFullscreen();
        }
    });
});
</script>
{% endblock %}